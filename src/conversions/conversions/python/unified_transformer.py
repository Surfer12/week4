# Unified Transformer Monolith
# This file has been automatically generated by merging the following files:
#   - unified_transformer.py
#   - number_conversion_interactive.py
#   - circuit_visualization.py
#   - signed_representations.py
#   - number_conversion.py



# ---- START OF unified_transformer.py ----

'''\
Unified Computational State Transformer Module

This module integrates number system conversions, truth table processing,
K-Map generation, and Gray code mapping into a single unified transformation
engine.

Modules:
  - NumberSystemTransformer: converts numbers between bases.
  - TruthTableProcessor: generates truth tables from numeric states.
  - KMapGenerator: creates K-Map projections.
  - GrayCodeIdentifier: maps binary states to Gray code.
  - UnifiedNumberTransformer: integrates the above components.

Author: Your Name
Date: 2023-10-XX
'''

import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), "../conversions/python"))
from number_conversion_interactive import show_decimal_to_binary_steps, show_ieee754_visualization, show_multi_base_layout

class NumberSystemTransformer:
    def convert(self, value):
        # Convert the input number to a binary string representation
        try:
            n = abs(int(float(value)))
            return format(n, 'b')
        except ValueError:
            return ''


class TruthTableProcessor:
    def process(self, binary_str):
        # Generate a simple truth table from a binary string
        # Each row is a dictionary with the bit position and bit value
        truth_table = []
        for index, bit in enumerate(binary_str):
            truth_table.append({'position': index, 'bit': bit})
        return truth_table


class KMapGenerator:
    def generate(self, truth_table):
        # Create a dummy K-Map projection for demonstration purposes
        # Assuming a simple 2-variable K-Map with columns: '00', '01', '11', '10'
        kmap = {'x2_0': [0, 0, 0, 0], 'x2_1': [0, 0, 0, 0]}
        if truth_table:
            # For demonstration, fill the first cell with the first bit's integer value
            try:
                kmap['x2_0'][0] = int(truth_table[0]['bit'])
            except ValueError:
                pass
        return kmap


class GrayCodeIdentifier:
    def apply_gray_code_mapping(self, truth_table):
        # Apply Gray code conversion to each row in the truth table
        # Gray code conversion: gray = binary ^ (binary >> 1)
        def to_gray(n):
            return n ^ (n >> 1)
        gray_table = []
        for row in truth_table:
            try:
                bit_val = int(row['bit'])
                gray_val = to_gray(bit_val)
                new_row = dict(row)
                new_row['gray'] = gray_val
                gray_table.append(new_row)
            except ValueError:
                new_row = dict(row)
                new_row['gray'] = row['bit']
                gray_table.append(new_row)
        return gray_table


class DefaultLanguageAdapter:
    def adapt(self, computational_state, target_language='python'):
        # For now, simply return the computational state without changes
        return computational_state


class UnifiedNumberTransformer:
    def __init__(self, language_adapter=None):
        self.language_adapter = language_adapter or DefaultLanguageAdapter()
        self.number_converter = NumberSystemTransformer()
        self.truth_table_processor = TruthTableProcessor()
        self.kmap_generator = KMapGenerator()
        self.gray_code_analyzer = GrayCodeIdentifier()

    def transform_computational_state(self, input_value):
        # Convert number using number system transformer
        converted_state = self.number_converter.convert(input_value)

        # Process the truth table from the binary representation
        truth_table = self.truth_table_processor.process(converted_state)

        # Generate the K-Map representation
        kmap_rep = self.kmap_generator.generate(truth_table)

        # Apply Gray code mapping to the truth table
        gray_coded_states = self.gray_code_analyzer.apply_gray_code_mapping(truth_table)

        # Adapt the computational state if needed
        adapted_state = self.language_adapter.adapt(kmap_rep, target_language='python')

        return {
            'converted_state': converted_state,
            'truth_table': truth_table,
            'kmap_representation': kmap_rep,
            'gray_coded_states': gray_coded_states,
            'adapted_state': adapted_state
        }


def display_transformation_result(result):
    print("\n=== Unified Transformation Result ===\n")
    print(f"Converted State: {result['converted_state']}\n")
    print("Digital Design Best Practices Summary:")
    print("  1. Begin with a comprehensive truth table that captures all input combinations and their outputs.")
    print("  2. Leverage Karnaugh Maps (K-maps) with Gray code ordering to simplify and validate Boolean expressions.")
    print("  3. Adapt the computational state into Python for effective simulation and further analysis.")
    print("Follow these guidelines to design, analyze, and validate digital circuits accurately.\n")

    for i, tt in enumerate(result['truth_tables']):
        print(f"Truth Table {i+1}:")
        print("This section provides a detailed view of each bit's logic state and its Gray code conversion.")
        print("{:<10} {:<10} {:<10}".format("Index", "Bit", "Gray"))
        for row in result['gray_coded_states_list'][i]:
            print("{:<10} {:<10} {:<10}".format(row['position'], row['bit'], row['gray']))

        print("\nK-Map Representation:")
        print("The Karnaugh Map (K-Map) aids in simplifying Boolean expressions by visually grouping adjacent bits.")
        for key, value in result['kmap_representations'][i].items():
            print(f"{key}: {value}")

        print("\nAdapted State:")
        print("The Adapted State bridges the raw digital computations and their representation in Python.")
        print("{:<10} {:<30}".format("Key", "Value"))
        for key, value in result['adapted_states'][i].items():
            print("{:<10} {:<30}".format(key, str(value)))
        print("\n" + "="*40 + "\n")


def add_extra_rows(truth_table):
    print("Adding extra rows to the current truth table.")
    while True:
        row_input = input("Enter extra row as 'position,bit' (or type 'done' to finish, 'view' to display table, 'bulk:' to enter multiple rows): ")
        if row_input.lower() == 'done':
            break
        elif row_input.lower() == 'view':
            print("\nCurrent Truth Table:")
            for row in truth_table:
                print(row)
            continue
        elif row_input.lower().startswith('bulk:'):
            bulk_data = row_input[5:].strip()
            entries = [entry.strip() for entry in bulk_data.split(';') if entry.strip()]
            for entry in entries:
                parts = entry.split(',')
                if len(parts) != 2:
                    print(f"Invalid bulk entry: {entry}. Expected format 'position,bit'.")
                    continue
                try:
                    pos = int(parts[0].strip())
                    bit = parts[1].strip()
                    truth_table.append({'position': pos, 'bit': bit})
                except Exception as e:
                    print(f"Error processing entry {entry}: {e}")
            continue
        elif row_input.strip() == "":
            print("Empty input. Please enter valid data.")
            continue
        else:
            parts = row_input.split(',')
            if len(parts) != 2:
                print("Invalid input format. Please enter in the format 'position,bit'.")
                continue
            try:
                pos = int(parts[0].strip())
                bit = parts[1].strip()
                truth_table.append({'position': pos, 'bit': bit})
            except Exception as e:
                print(f"Error processing input: {e}")
    # Sort the truth table by position
    truth_table = sorted(truth_table, key=lambda x: x['position'])
    return truth_table


def create_new_truth_table():
    print("Creating a new truth table.")
    new_table = []
    while True:
        row_input = input("Enter row as 'position,bit' (or type 'done' to finish, 'view' to display current table, 'bulk:' for multiple rows): ")
        if row_input.lower() == 'done':
            break
        elif row_input.lower() == 'view':
            print("\nCurrent New Truth Table:")
            for row in new_table:
                print(row)
            continue
        elif row_input.lower().startswith('bulk:'):
            bulk_data = row_input[5:].strip()
            entries = [entry.strip() for entry in bulk_data.split(';') if entry.strip()]
            for entry in entries:
                parts = entry.split(',')
                if len(parts) != 2:
                    print(f"Invalid bulk entry: {entry}. Expected format 'position,bit'.")
                    continue
                try:
                    pos = int(parts[0].strip())
                    bit = parts[1].strip()
                    new_table.append({'position': pos, 'bit': bit})
                except Exception as e:
                    print(f"Error processing entry {entry}: {e}")
            continue
        elif row_input.strip() == "":
            print("Empty input. Please enter valid data.")
            continue
        else:
            parts = row_input.split(',')
            if len(parts) != 2:
                print("Invalid input format. Please enter in the format 'position,bit'.")
                continue
            try:
                pos = int(parts[0].strip())
                bit = parts[1].strip()
                new_table.append({'position': pos, 'bit': bit})
            except Exception as e:
                print(f"Error processing input: {e}")
    new_table = sorted(new_table, key=lambda x: x['position'])
    return new_table


def main():
    sys.stdout.write("Enter a decimal number: ")
    sys.stdout.flush()
    input_value = input()
    try:
        decimal_value = float(input_value)
    except ValueError:
        print("Invalid decimal number.")
        return

    # Display conversion details
    show_decimal_to_binary_steps(decimal_value)
    show_ieee754_visualization(decimal_value)
    show_multi_base_layout(decimal_value)

    transformer = UnifiedNumberTransformer()
    result = transformer.transform_computational_state(input_value)

    # Prepare lists to hold multiple truth tables and their corresponding data
    truth_tables = [result['truth_table']]
    kmap_representations = [result['kmap_representation']]
    gray_coded_states_list = [result['gray_coded_states']]
    adapted_states = [result['adapted_state']]

    # Interactive prompt to modify the default truth table or add new ones
    while True:
        print("Do you want to modify the truth tables?", flush=True)
        print("1: Add extra rows to the default truth table", flush=True)
        print("2: Add a completely new truth table", flush=True)
        print("3: Continue", flush=True)
        sys.stdout.write("Enter your choice (1/2/3): ")
        sys.stdout.flush()
        choice = input()
        if choice == '1':
            new_tt = add_extra_rows(truth_tables[-1])
        elif choice == '2':
            new_tt = create_new_truth_table()
        elif choice == '3':
            break

    # After exiting interactive prompt, display the final transformation result
    final_result = {
        'converted_state': result['converted_state'],
        'truth_tables': truth_tables,
        'kmap_representations': kmap_representations,
        'gray_coded_states_list': gray_coded_states_list,
        'adapted_states': adapted_states
    }
    display_transformation_result(final_result)


if __name__ == "__main__":
    main()

# ---- END OF unified_transformer.py ----


# ---- START OF number_conversion_interactive.py ----

# =========================================
# File: number_conversion_interactive.py
# Description:
#   Interactive utility for number system conversions
#   with step-by-step visualization.
# =========================================

import struct

# Insert unified imports from core number_conversion
from ..core.number_conversion import (Colors, decimal_to_binary_float, binary_to_decimal, binary_to_decimal_float, to_ieee754, group_bits, color_binary_groups, to_base32, parse_number)

def create_power_table(decimal_value: float, max_exponent: int = 10, show_fractional: bool = False) -> None:
    """
    Prints a table showing powers of 2 and whether they fit in decimal_value.
    """
    int_part = int(decimal_value)
    if show_fractional:
        print("| Power (2^n) | Value      | Does {} fit? | Binary Bit |".format(decimal_value))
    else:
        print("| Power (2^n) | Value      | Does {} fit? | Binary Bit |".format(int_part))
    print("|-------------|------------|--------------|------------|")

    remainder = int_part
    for n in range(max_exponent, -1, -1):
        power_value = 1 << n  # 2^n
        if power_value <= remainder:
            remainder_str = f"(leftover={remainder - power_value})"
            print(f"| 2^{n:<9} | {power_value:<10} | Yes {remainder_str:<8} | 1          |")
            remainder -= power_value
        else:
            print(f"| 2^{n:<9} | {power_value:<10} | No           | 0          |")

def create_fractional_power_table(fractional_part: float, precision: int = 4) -> None:
    """
    Prints a table showing negative powers of 2 for fractional part.
    """
    print("\nFractional part powers:")
    print("| Power (2^-n) | Value      | Does {} fit? | Binary Bit |".format(fractional_part))
    print("|--------------|------------|--------------|------------|")

    remainder = fractional_part
    for n in range(1, precision + 1):
        power_value = 2 ** -n
        if power_value <= remainder:
            remainder_str = f"(leftover={remainder - power_value:.6f})"
            print(f"| 2^-{n:<8} | {power_value:<10.6f} | Yes {remainder_str:<8} | 1          |")
            remainder -= power_value
        else:
            print(f"| 2^-{n:<8} | {power_value:<10.6f} | No           | 0          |")

def show_decimal_to_binary_steps(decimal_value: float, int_bits: int = 32, frac_bits: int = 4) -> str:
    """Show step-by-step decimal to binary conversion."""
    print(f"\n=== Decimal to Binary Conversion Steps ===")
    print(f"Converting {decimal_value} to binary\n")

    int_part = int(decimal_value)
    frac_part = abs(decimal_value - int_part)

    is_negative = decimal_value < 0
    abs_value = abs(int_part)

    # Integer part conversion
    if is_negative:
        print(f"1. Take absolute value: |{decimal_value}| = {abs(decimal_value)}")
        print(f"2. Split into integer and fractional parts:")
        print(f"   Integer part: {abs_value}")
        print(f"   Fractional part: {frac_part}")
        print("\n3. Convert absolute integer part to binary:")
    else:
        print(f"1. Split into integer and fractional parts:")
        print(f"   Integer part: {int_part}")
        print(f"   Fractional part: {frac_part}")
        print("\n2. Convert integer part to binary:")

    create_power_table(abs_value, int_bits-1)

    # Fractional part conversion
    if frac_part > 0:
        print("\n3. Convert fractional part to binary:")
        create_fractional_power_table(frac_part, frac_bits)

    # Get final binary representation
    bin_str = decimal_to_binary_float(decimal_value, int_bits, frac_bits)
    print(f"\nFinal binary: {bin_str}")
    return bin_str

def show_binary_to_decimal_steps(binary_str: str) -> float:
    """Show step-by-step binary to decimal conversion."""
    print(f"\n=== Binary to Decimal Conversion Steps ===")
    print(f"Converting {binary_str} to decimal\n")

    # Split into integer and fractional parts
    if '.' in binary_str:
        parts = binary_str.split('.')
    else:
        parts = [binary_str]
    int_part = parts[0]
    frac_part = parts[1] if len(parts) > 1 else ''

    # Integer part conversion
    is_negative = int_part and int_part[0] == '1'
    if is_negative:
        print("1. Number is negative (leftmost bit is 1)")
        print("2. Using two's complement for integer part:")
        print(f"   a. Original binary:     {int_part}")

        # Invert bits
        inverted = ''.join('1' if bit == '0' else '0' for bit in int_part)
        print(f"   b. Invert all bits:     {inverted}")

        # Add 1 and convert
        int_value = binary_to_decimal(int_part)
        print(f"   c. Add 1 and convert:   {int_value}")
    else:
        print("1. Integer part is positive (leftmost bit is 0)")
        int_value = binary_to_decimal(int_part)
        if int_part:
            print("2. Calculate integer powers of 2:")
            total = 0
            for i, bit in enumerate(reversed(int_part)):
                if bit == '1':
                    value = 1 << i
                    total += value
                    print(f"   2^{i} = {value}")
            print(f"\nInteger sum = {total}")

    # Fractional part conversion
    if frac_part:
        print("\n3. Convert fractional part:")
        print("   Calculate negative powers of 2:")
        frac_value = 0.0
        for i, bit in enumerate(frac_part, 1):
            if bit == '1':
                value = 2 ** -i
                frac_value += value
                print(f"   2^-{i} = {value}")
        print(f"\nFractional sum = {frac_value}")
        final_value = float(int_value) + frac_value
    else:
        final_value = float(int_value)

    print(f"\nFinal decimal value: {final_value}")
    return final_value

def show_ieee754_visualization(value: float) -> None:
    """Show detailed IEEE-754 single precision representation."""
    print("\n=== IEEE-754 Single Precision Visualization ===")
    print(f"Converting {value} to IEEE-754 format\n")

    ieee = to_ieee754(value)

    # Show binary layout
    print("Binary layout (32 bits):")
    print("| Sign | Exponent | Mantissa |")
    print("|-------|-----------|-----------|")
    print(f"|   {ieee['sign']}   | {ieee['exponent']} | {ieee['mantissa']} |")

    # Show detailed breakdown
    print("\nComponent breakdown:")
    print(f"1. Sign bit: {ieee['sign']} ({'negative' if ieee['sign_value'] else 'positive'})")
    print(f"2. Exponent: {ieee['exponent']} (binary) = {ieee['exponent_raw']} (decimal)")
    print(f"   - Bias: 127")
    print(f"   - Actual exponent: {ieee['exponent_raw']} - 127 = {ieee['exponent_bias']}")
    print(f"3. Mantissa: 1.{ieee['mantissa']} = {ieee['mantissa_value']}")

    # Show final calculation
    print("\nFinal value calculation:")
    print(f"(-1)^{ieee['sign_value']} × {ieee['mantissa_value']} × 2^{ieee['exponent_bias']}")
    print(f"= {value}")

def show_bit_mapping(bin_str: str) -> None:
    """Show how bits map between different bases."""
    print("\nBit Mapping:")

    # Split into integer and fractional parts if needed
    if '.' in bin_str:
        parts = bin_str.split('.')
    else:
        parts = [bin_str]
    int_part = parts[0]
    frac_part = parts[1] if len(parts) > 1 else ''

    # Pad integer part to multiple of 12 (LCM of 3 and 4 for octal and hex grouping)
    pad_len = (12 - len(int_part) % 12) % 12
    padded_bin = '0' * pad_len + int_part

    print("Binary groups (4 bits):")
    print(' '.join(padded_bin[i:i+4] for i in range(0, len(padded_bin), 4)))
    print("Hex digits:           ", end='')
    for i in range(0, len(padded_bin), 4):
        group = padded_bin[i:i+4]
        print(f"  {format(int(group, 2), 'X')}  ", end='')
    print("\n")

    print("Binary groups (3 bits):")
    print(' '.join(padded_bin[i:i+3] for i in range(0, len(padded_bin), 3)))
    print("Octal digits:         ", end='')
    for i in range(0, len(padded_bin), 3):
        group = padded_bin[i:i+3]
        print(f" {format(int(group, 2), 'o')} ", end='')
    print("\n")

    if frac_part:
        print("Fractional part mapping:")
        # Pad fractional part to multiple of 4 for hex grouping
        frac_pad = (4 - len(frac_part) % 4) % 4
        padded_frac = frac_part + '0' * frac_pad

        print("Binary groups:", ' '.join(padded_frac[i:i+4] for i in range(0, len(padded_frac), 4)))
        print("Hex digits:  ", end='')
        for i in range(0, len(padded_frac), 4):
            group = padded_frac[i:i+4]
            print(f"  {format(int(group, 2), 'X')}  ", end='')
        print()

def perform_binary_arithmetic(a: str, b: str, operation: str = 'add') -> tuple[str, list[str]]:
    """Perform binary arithmetic operations with step-by-step explanation."""
    # Remove '0b' prefix if present
    a = a[2:] if a.startswith('0b') else a
    b = b[2:] if b.startswith('0b') else b

    # Ensure equal length for add/sub; for multiply, we'll handle differently
    max_len = max(len(a), len(b))

    if operation in ['add', 'subtract']:
        a = a.zfill(max_len)
        b = b.zfill(max_len)

    if operation == 'add':
        # Binary addition
        carry = 0
        result = ''
        steps = []

        for i in range(max_len-1, -1, -1):
            bit_a = int(a[i])
            bit_b = int(b[i])
            current_sum = bit_a + bit_b + carry
            result = str(current_sum % 2) + result
            carry = current_sum // 2
            steps.append(f"Position {max_len-i}: {bit_a} + {bit_b} + carry({carry}) = {current_sum}")

        if carry:
            result = '1' + result
            steps.append("Final carry: 1")

        return result, steps

    elif operation == 'subtract':
        # Two's complement subtraction
        # Convert b to its two's complement
        b_complement = ''
        for bit in b:
            b_complement += '1' if bit == '0' else '0'

        # Add 1 to get two's complement
        carry = 1
        b_twos = ''
        for i in range(max_len-1, -1, -1):
            bit = int(b_complement[i])
            current_sum = bit + carry
            b_twos = str(current_sum % 2) + b_twos
            carry = current_sum // 2

        # Now add a and b_twos
        carry = 0
        result = ''
        steps = ["Two's complement steps:"]
        steps.append(f"1. Invert bits:     {b} → {b_complement}")
        steps.append(f"2. Add 1:           {b_complement} → {b_twos}")
        steps.append("\nSubtraction steps (using addition with two's complement):")

        for i in range(max_len-1, -1, -1):
            bit_a = int(a[i])
            bit_b = int(b_twos[i])
            current_sum = bit_a + bit_b + carry
            result = str(current_sum % 2) + result
            carry = current_sum // 2
            steps.append(f"Position {max_len-i}: {bit_a} + {bit_b} + carry({carry}) = {current_sum}")

        return result, steps
    elif operation == 'multiply':
        steps = []
        partials = []

        # For multiplication, result can be up to sum of bit lengths
        result_len = len(a) + len(b)

        # Zero-extend both strings for consistent alignment
        A = a.zfill(result_len)
        B = b.zfill(result_len)

        accumulator = 0
        steps.append(f"Multiplication (bit-by-bit partial products):\n  A = {a}, B = {b}")

        # Generate partial products
        for i in range(len(B)):
            bit_idx = len(B) - 1 - i
            bit_b = int(B[bit_idx])

            if bit_b == 1:
                partial_val = int(A, 2) << i
                accumulator += partial_val

                partial_bin = format(partial_val, f"0{result_len}b")
                steps.append(f"Step {i+1}: B[{bit_idx}] = 1:")
                steps.append(f"  Shift A left by {i}:")
                steps.append(f"  {color_binary_groups(partial_bin)}")
                partials.append(partial_val)
            else:
                steps.append(f"Step {i+1}: B[{bit_idx}] = 0 → Skip (partial product = 0)")

        # Show running sum after each partial product
        if len(partials) > 0:
            steps.append("\nRunning sums:")
            running_sum = 0
            for i, partial in enumerate(partials, 1):
                running_sum += partial
                sum_bin = format(running_sum, f"0{result_len}b")
                steps.append(f"After partial product {i}: {color_binary_groups(sum_bin)}")

        result = format(accumulator, f"0{result_len}b")
        steps.append(f"\nFinal result: {color_binary_groups(result)}")

        return result, steps
    elif operation == 'divide':
        if all(bit == '0' for bit in b):
            raise ValueError("Division by zero")

        steps = []
        # Convert to integers for division
        dividend = int(a, 2)
        divisor = int(b, 2)

        # Store original values for step display
        orig_dividend = format(dividend, f'0{len(a)}b')
        orig_divisor = format(divisor, f'0{len(b)}b')

        steps.append(f"Division: {color_binary_groups(orig_dividend)} ÷ {color_binary_groups(orig_divisor)}")
        steps.append("\nStep-by-step division:")

        # Find the position of the first 1 in the dividend
        first_one = 0
        temp_dividend = dividend
        while temp_dividend > 0:
            first_one += 1
            temp_dividend >>= 1

        # Find position of first 1 in divisor
        first_one_divisor = 0
        temp_divisor = divisor
        while temp_divisor > 0:
            first_one_divisor += 1
            temp_divisor >>= 1

        # Initialize quotient and remainder
        quotient = 0
        remainder = dividend

        # Track each step
        step_num = 1
        while remainder >= divisor and first_one >= first_one_divisor:
            # Calculate current bit position
            shift = first_one - first_one_divisor

            # Try to subtract shifted divisor
            shifted_divisor = divisor << shift
            if remainder >= shifted_divisor:
                remainder -= shifted_divisor
                quotient |= (1 << shift)

                # Show the step
                steps.append(f"\nStep {step_num}:")
                steps.append(f"Current remainder: {color_binary_groups(format(remainder, 'b').zfill(len(a)))}")
                steps.append(f"Shifted divisor:   {color_binary_groups(format(shifted_divisor, 'b').zfill(len(a)))}")
                steps.append(f"After subtraction: {color_binary_groups(format(remainder, 'b').zfill(len(a)))}")
                steps.append(f"Current quotient:  {color_binary_groups(format(quotient, 'b'))}")
                step_num += 1

            first_one -= 1

        # Format results
        quotient_bin = format(quotient, f'0{len(a)}b')
        remainder_bin = format(remainder, f'0{len(b)}b')

        steps.append(f"\nFinal Results:")
        steps.append(f"Quotient:  {color_binary_groups(quotient_bin)}")
        steps.append(f"Remainder: {color_binary_groups(remainder_bin)}")

        return quotient_bin, steps
    else:
        raise ValueError(f"Unknown operation: {operation}")

def show_arithmetic_operation(a: float, b: float, operation: str = 'add') -> None:
    """Show binary arithmetic operation with step-by-step explanation."""
    from signed_representations import check_overflow, show_carry_chain, show_number_representations

    print(f"\n=== Binary {operation.capitalize()}ition ===")

    # Convert to binary
    a_bin = format(int(a), 'b')
    b_bin = format(int(b), 'b')

    # Ensure equal length and add color
    max_len = max(len(a_bin), len(b_bin))
    if operation != 'multiply':
        max_len += 1  # Extra bit for carry/borrow

    print("\nOperands:")
    print(f"A = {a:10} = {color_binary_groups(a_bin)}")
    print(f"B = {b:10} = {color_binary_groups(b_bin)}")

    # Show number representations for both operands
    print("\nNumber Representations:")
    print("\nOperand A:")
    show_number_representations(int(a), max_len)
    print("\nOperand B:")
    show_number_representations(int(b), max_len)

    # Show carry chain for add/subtract
    if operation in ['add', 'subtract']:
        show_carry_chain(a_bin.zfill(max_len), b_bin.zfill(max_len), operation)
    elif operation == 'divide' and b == 0:
        print("\nError: Division by zero!")
        return

    # Perform operation
    try:
        result_bin, steps = perform_binary_arithmetic(a_bin, b_bin, operation)
    except ValueError as e:
        if str(e) == "Division by zero":
            print("\nError: Division by zero!")
            return
        raise

    # Show detailed steps
    print("\nDetailed Steps:")
    for step in steps:
        print(step)

    # Show result and check for overflow
    result_dec = int(result_bin, 2)
    check_len = max_len
    has_overflow, overflow_msg = check_overflow(int(a), int(b), result_dec, check_len, operation)

    print(f"\nResult:")
    if operation == 'divide':
        remainder_bin = format(int(a) % int(b), f'0{len(b_bin)}b')
        print(f"Quotient (Binary):  {color_binary_groups(result_bin)}")
        print(f"Quotient (Decimal): {result_dec}")
        print(f"Remainder (Binary): {color_binary_groups(remainder_bin)}")
        print(f"Remainder (Decimal): {int(a) % int(b)}")
    else:
        print(f"Binary:  {color_binary_groups(result_bin)}")
        print(f"Decimal: {result_dec}")

    if has_overflow:
        print(f"\nWarning: {overflow_msg}")

    # Show result's number representations
    print("\nResult representations:")
    show_number_representations(result_dec, check_len)

def show_multi_base_layout(value: float) -> None:
    """Show the number in decimal, hexadecimal, binary, octal, and base32 formats."""
    print("\n=== Multi-Base Representation ===")

    # Handle integer and fractional parts separately
    int_part = int(value)
    frac_part = abs(value - int_part)

    # Format integer part in different bases
    hex_int = format(abs(int_part), 'X')
    oct_int = format(abs(int_part), 'o')
    bin_int = format(abs(int_part), 'b')

    # Format fractional part (if exists)
    if frac_part > 0:
        # Convert fraction to binary (up to 12 bits precision)
        bin_frac = ""
        frac = frac_part
        for _ in range(12):  # Increased precision for better octal conversion
            frac *= 2
            if frac >= 1:
                bin_frac += "1"
                frac -= 1
            else:
                bin_frac += "0"

        # Convert binary fraction to hex and octal
        hex_frac = ""
        for i in range(0, len(bin_frac), 4):
            chunk = bin_frac[i:i+4].ljust(4, '0')
            hex_digit = format(int(chunk, 2), 'X')
            hex_frac += hex_digit

        oct_frac = ""
        for i in range(0, len(bin_frac), 3):
            chunk = bin_frac[i:i+3].ljust(3, '0')
            oct_digit = format(int(chunk, 2), 'o')
            oct_frac += oct_digit

    # Create layout table
    print("\nNumber Layout:")
    print("┌─────────┬────────────────────────────────────────┐")
    print("│ Base    │ Representation                         │")
    print("├─────────┼────────────────────────────────────────┤")

    # Decimal (Base 10)
    print(f"│ Base 10 │ {value:<40} │")

    # Hexadecimal (Base 16)
    if frac_part > 0:
        hex_repr = f"{'-' if value < 0 else ''}0x{hex_int}.{hex_frac}"
    else:
        hex_repr = f"{'-' if value < 0 else ''}0x{hex_int}"
    print(f"│ Base 16 │ {hex_repr:<40} │")

    # Base 32
    base32_repr = to_base32(abs(value))
    if value < 0:
        base32_repr = f"-{base32_repr}"
    print(f"│ Base 32 │ {base32_repr:<40} │")

    # Octal (Base 8)
    if frac_part > 0:
        oct_repr = f"{'-' if value < 0 else ''}0o{oct_int}.{oct_frac}"
    else:
        oct_repr = f"{'-' if value < 0 else ''}0o{oct_int}"
    print(f"│ Base 8  │ {oct_repr:<40} │")

    # Binary (Base 2)
    if frac_part > 0:
        bin_repr = f"{'-' if value < 0 else ''}0b{bin_int}.{bin_frac}"
    else:
        bin_repr = f"{'-' if value < 0 else ''}0b{bin_int}"
    colored_bin = color_binary_groups(bin_repr[2:])
    print(f"│ Base 2  │ {colored_bin:<40} │")
    print("└─────────┴────────────────────────────────────────┘")

    # Show bit patterns with grouping
    print("\nBit Patterns:")
    if frac_part > 0:
        print(f"Binary integer part:  {group_bits(bin_int)}")
        print(f"Binary fraction part: {group_bits(bin_frac)}")
    else:
        print(f"Binary pattern: {group_bits(bin_int)}")

    # Show bit mapping between bases
    show_bit_mapping(bin_int + ('.' + bin_frac if frac_part > 0 else ''))

    # Show conversion steps
    print("\nConversion Steps:")
    print("1. Decimal to Hexadecimal:")
    print(f"   {value} (base 10) = {hex_repr} (base 16)")
    print("2. Decimal to Octal:")
    print(f"   {value} (base 10) = {oct_repr} (base 8)")
    print("3. Decimal to Binary:")
    print(f"   {value} (base 10) = {bin_repr} (base 2)")
    if frac_part > 0:
        print("4. Fractional part conversion:")
        print(f"   0.{bin_frac} (binary) = {frac_part} (decimal)")

def print_static_circuit_diagram() -> None:
    """Print a static circuit diagram example."""
    print("--- Full Circuit Diagram ---")
    print("Input --[NAND (1-bit)]--> --[NAND (1-bit)]--> --[XNOR (1-bit)]--> Output")
    print("")
    print("--- Advanced Details for Component 1 (NAND) ---")
    print("Truth Table:")
    print("A B | NAND")
    print("0 0 | 1")
    print("0 1 | 1")
    print("1 0 | 1")
    print("1 1 | 0")
    print("")
    print("K-map:")
    print("      B=0   B=1")
    print("A=0:   1     1")
    print("A=1:   1     0")
    print("")
    print("SOP Expression:")
    print("Output = A'B' + A'B + AB'")

def main():
    import sys
    from pathlib import Path

    # Add the root directory to Python path
    root_dir = Path(__file__).parent.parent
    if str(root_dir) not in sys.path:
        sys.path.append(str(root_dir))

    while True:
        print("\n=== Binary Number System Educational Tool (BNSET) ===")
        print("0. Static Diagram Example")
        print("1. Decimal to Binary")
        print("2. Binary to Decimal")
        print("3. Show IEEE-754 Format")
        print("4. Show Multi-Base Layout")
        print("5. Binary Arithmetic")
        print("6. Show Number Representations")
        print("7. Show Overflow Cases")
        print("8. Circuit Visualization")
        print("9. Educational Tools")
        print("10. Exit")
        try:
            choice = input("Enter choice (0-10): ")

            if choice == "9":
                from educational.educational_components import main as educational_menu
                educational_menu()
            elif choice == "10":
                print("\nThank you for using BNSET!")
                break
            elif choice == "8":
                from conversions.visualization.circuit_visualization import show_circuit_menu
                show_circuit_menu()
            elif choice == "7":
                bits = int(input("Enter number of bits to demonstrate (4-8, default 4): ") or "4")
                if bits < 4 or bits > 8:
                    print("Number of bits must be between 4 and 8")
                    continue
                from signed_representations import show_overflow_cases
                show_overflow_cases(bits)
            elif choice == "5":
                print("\nBinary Arithmetic Operations:")
                print("1. Addition")
                print("2. Subtraction")
                print("3. Multiplication")
                print("4. Division")
                op_choice = input("Choose operation (1-4): ")

                print("\nEnter numbers in any format:")
                print("- Decimal: 42")
                print("- Binary: 0b101010 or 101010")
                print("- Hex: 0x2A")

                a_str = input("Enter first number: ")
                b_str = input("Enter second number: ")

                # Try to parse in different bases
                try:
                    if a_str.startswith(('0b', '0B')):
                        a = parse_number(a_str, 2)
                    elif a_str.startswith(('0x', '0X')):
                        a = parse_number(a_str, 16)
                    else:
                        a = parse_number(a_str, 10)

                    if b_str.startswith(('0b', '0B')):
                        b = parse_number(b_str, 2)
                    elif b_str.startswith(('0x', '0X')):
                        b = parse_number(b_str, 16)
                    else:
                        b = parse_number(b_str, 10)
                except ValueError:
                    print("Error: Invalid number format")
                    continue

                operation = {
                    '1': 'add',
                    '2': 'subtract',
                    '3': 'multiply',
                    '4': 'divide'
                }.get(op_choice, 'add')

                show_arithmetic_operation(float(a), float(b), operation)
            elif choice == "6":
                print("\nEnter number in any format:")
                print("- Decimal: 42")
                print("- Binary: 0b101010 or 101010")
                print("- Hex: 0x2A")

                value_str = input("Enter number: ")
                try:
                    if value_str.startswith(('0b', '0B')):
                        value = parse_number(value_str, 2)
                    elif value_str.startswith(('0x', '0X')):
                        value = parse_number(value_str, 16)
                    else:
                        value = parse_number(value_str, 10)
                except ValueError:
                    print("Error: Invalid number format")
                    continue

                bits = int(input("Enter number of bits (default 8): ") or "8")
                from signed_representations import show_number_representations
                show_number_representations(value, bits)
            elif choice == "1":
                value = float(input("Enter decimal number: "))
                show_decimal_to_binary_steps(value)
                show_ieee754_visualization(value)
                show_multi_base_layout(value)
            elif choice == "2":
                value = input("Enter binary number: ")
                result = show_binary_to_decimal_steps(value)
                if '.' in value:  # Show IEEE-754 for fractional results
                    show_ieee754_visualization(result)
                show_multi_base_layout(float(result))
            elif choice == "3":
                value = float(input("Enter decimal number for IEEE-754 visualization: "))
                show_ieee754_visualization(value)
                show_multi_base_layout(value)
            elif choice == "4":
                value = float(input("Enter decimal number for multi-base visualization: "))
                show_multi_base_layout(value)
            elif choice == "0":
                print_static_circuit_diagram()
                input("\nPress Enter to continue...")
                continue

        except ValueError as e:
            print(f"Error: Invalid input - {e}")
            continue
        except KeyboardInterrupt:
            print("\nExiting...")
            break

if __name__ == "__main__":
    main()

# ---- END OF number_conversion_interactive.py ----


# ---- START OF circuit_visualization.py ----

# =========================================
# File: circuit_visualization.py
# Description:
#   Circuit-level visualization of binary operations
#   showing gates and digital logic implementation.
# =========================================

class Colors:
    """ANSI color codes for terminal output."""
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    CYAN = '\033[96m'
    MAGENTA = '\033[95m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def show_half_adder(a: int, b: int) -> None:
    """Visualize a half adder circuit with inputs and outputs."""
    sum_bit = a ^ b  # XOR
    carry = a & b    # AND

    print("\n=== Half Adder Circuit ===")
    print(f"Inputs:  A = {a}, B = {b}")
    print("\nCircuit Diagram:")
    print("     A─────┬─────►XOR──────►Sum")
    print("           │      ▲")
    print("           │      │")
    print("     B─────┼──────┘")
    print("           │")
    print("           └─────►AND──────►Carry")
    print("\nGate Operations:")
    print(f"XOR Gate: {a} ⊕ {b} = {sum_bit}")
    print(f"AND Gate: {a} & {b} = {carry}")
    print("\nOutputs:")
    print(f"Sum:   {sum_bit}")
    print(f"Carry: {carry}")

    print("\nK-map for XOR (Sum):")
    print("      B=0   B=1")
    print("A=0:   0     1")
    print("A=1:   1     0")

    print("\nK-map for AND (Carry):")
    print("      B=0   B=1")
    print("A=0:   0     0")
    print("A=1:   0     1")

def show_full_adder(a: int, b: int, c_in: int) -> None:
    """Visualize a full adder circuit with inputs and outputs."""
    # First half adder
    sum1 = a ^ b
    carry1 = a & b

    # Second half adder
    sum_out = sum1 ^ c_in
    carry2 = sum1 & c_in

    # OR gate for final carry
    carry_out = carry1 | carry2

    print("\n=== Full Adder Circuit ===")
    print(f"Inputs: A = {a}, B = {b}, Carry_in = {c_in}")
    print("\nCircuit Diagram:")
    print("     A─────┬─────►XOR─────┬─────►XOR──────►Sum")
    print("           │      ▲       │      ▲")
    print("           │      │       │      │")
    print("     B─────┼──────┘       │      │")
    print("           │              │      │")
    print("           └─────►AND─────┼──────┘")
    print("                  │       │")
    print("                  │       │")
    print("   Cin───────────┼───────┘")
    print("                  │")
    print("                  └─────►OR───────►Carry")
    print("\nGate Operations:")
    print("First Half Adder:")
    print(f"XOR1: {a} ⊕ {b} = {sum1}")
    print(f"AND1: {a} & {b} = {carry1}")
    print("\nSecond Half Adder:")
    print(f"XOR2: {sum1} ⊕ {c_in} = {sum_out}")
    print(f"AND2: {sum1} & {c_in} = {carry2}")
    print("\nFinal Carry:")
    print(f"OR: {carry1} | {carry2} = {carry_out}")
    print("\nOutputs:")
    print(f"Sum:        {sum_out}")
    print(f"Carry_out:  {carry_out}")

    print("\nK-map for Sum (A ⊕ B ⊕ Cin):")
    print("      BC")
    print("     00  01  11  10")
    print("A=0:  0   1   0   1")
    print("A=1:  1   0   1   0")

    print("\nK-map for Carry:")
    print("      BC")
    print("     00  01  11  10")
    print("A=0:  0   0   1   1")
    print("A=1:  0   1   1   1")

def show_ripple_carry_adder(a: str, b: str) -> None:
    """Visualize a ripple carry adder for multi-bit addition."""
    # Ensure equal length
    max_len = max(len(a), len(b))
    a = a.zfill(max_len)
    b = b.zfill(max_len)

    print(f"\n=== {max_len}-bit Ripple Carry Adder ===")
    print("Input binary numbers:")
    print(f"A: {a}")
    print(f"B: {b}")

    # Process each bit position
    carry = 0
    result = ""
    carries = []

    print("\nBit-by-bit addition with full adders:")
    for i in range(max_len-1, -1, -1):
        bit_a = int(a[i])
        bit_b = int(b[i])

        # Calculate full adder outputs
        sum1 = bit_a ^ bit_b
        carry1 = bit_a & bit_b
        sum_out = sum1 ^ carry
        carry2 = sum1 & carry
        carry_next = carry1 | carry2

        print(f"\nBit position {max_len-1-i}:")
        print(f"Full Adder {i}:")
        print(f"  Inputs:  A={bit_a}, B={bit_b}, Cin={carry}")
        print(f"  Outputs: Sum={sum_out}, Cout={carry_next}")

        result = str(sum_out) + result
        carries.append(carry)
        carry = carry_next

    if carry:
        result = '1' + result
        carries.append(carry)

    print("\nFinal Result:")
    print(f"  {''.join(str(c) for c in carries[:-1])}  (Carries)")
    print(f"  {a}")
    print(f"+ {b}")
    print(f"  {'-' * max_len}")
    print(f"  {result}")

def print_static_circuit_diagram() -> None:
    """Print a static circuit diagram example."""
    print("--- Full Circuit Diagram ---")
    print("Input --[NAND (1-bit)]--> --[NAND (1-bit)]--> --[XNOR (1-bit)]--> Output")
    print("")
    print("--- Advanced Details for Component 1 (NAND) ---")
    print("Truth Table:")
    print("A B | NAND")
    print("0 0 | 1")
    print("0 1 | 1")
    print("1 0 | 1")
    print("1 1 | 0")
    print("")
    print("K-map:")
    print("      B=0   B=1")
    print("A=0:   1     1")
    print("A=1:   1     0")
    print("")
    print("SOP Expression:")
    print("Output = A'B' + A'B + AB'")

def show_circuit_menu() -> None:
    """Show menu for circuit-level visualizations."""
    while True:
        print("\n=== Circuit Visualization Menu ===")
        print("0. Show Static Diagram")
        print("1. Half Adder")
        print("2. Full Adder")
        print("3. Ripple Carry Adder")
        print("4. NOT Gate")
        print("5. OR Gate")
        print("6. NOR Gate")
        print("7. NAND Gate")
        print("8. XNOR Gate")
        print("9. Gate Chain Builder")
        print("10. Return to Main Menu")

        choice = input("Enter choice (0-10): ")

        if choice == "0":
            print_static_circuit_diagram()
            input("\nPress Enter to continue...")
            continue
        elif choice == "1":
            print("\nEnter two 1-bit numbers (0 or 1):")
            try:
                a = int(input("A: "))
                b = int(input("B: "))
                if a not in (0, 1) or b not in (0, 1):
                    print("Inputs must be 0 or 1")
                    continue
                show_half_adder(a, b)
            except ValueError:
                print("Invalid input")

        elif choice == "2":
            print("\nEnter three 1-bit numbers (0 or 1):")
            try:
                a = int(input("A: "))
                b = int(input("B: "))
                c = int(input("Carry in: "))
                if a not in (0, 1) or b not in (0, 1) or c not in (0, 1):
                    print("Inputs must be 0 or 1")
                    continue
                show_full_adder(a, b, c)
            except ValueError:
                print("Invalid input")

        elif choice == "3":
            print("\nEnter two binary numbers:")
            a = input("Enter first binary number: ")
            b = input("Enter second binary number: ")
            if not all(bit in '01' for bit in a + b):
                print("Invalid binary numbers")
                continue
            show_ripple_carry_adder(a, b)

        elif choice == "4":
            # NOT Gate
            print("\nEnter 1-bit input for NOT Gate (0 or 1):")
            try:
                a = int(input("A: "))
                if a not in (0, 1):
                    print("Input must be 0 or 1")
                    continue
                show_not_gate(a)
                adv = input("Show advanced details (truth table, K-map, SOP)? (y/n): ").strip().lower()
                if adv == "y":
                    print("\n--- Advanced Details for NOT Gate ---")
                    print("Truth Table:")
                    print("A | NOT A")
                    print("0 | 1")
                    print("1 | 0")
                    print("\nK-map for NOT Gate:")
                    print("A | NOT A")
                    print("0 | 1")
                    print("1 | 0")
                    print("\nSum of Products (SOP) Expression:")
                    print("Output = A' (True when A=0)")
            except ValueError:
                print("Invalid input")

        elif choice == "5":
            # OR Gate
            print("\nEnter two 1-bit numbers for OR Gate (0 or 1):")
            try:
                a = int(input("A: "))
                b = int(input("B: "))
                if a not in (0, 1) or b not in (0, 1):
                    print("Inputs must be 0 or 1")
                    continue
                show_or_gate(a, b)
                adv = input("Show advanced details (truth table, K-map, SOP)? (y/n): ").strip().lower()
                if adv == "y":
                    print("\n--- Advanced Details for OR Gate ---")
                    print("Truth Table:")
                    print("A B | A OR B")
                    print("0 0 |   0")
                    print("0 1 |   1")
                    print("1 0 |   1")
                    print("1 1 |   1")
                    print("\nK-map for OR Gate:")
                    print("      B=0   B=1")
                    print("A=0:   0     1")
                    print("A=1:   1     1")
                    print("\nSum of Products (SOP) Expression:")
                    print("Output = A + B")
            except ValueError:
                print("Invalid input")

        elif choice == "6":
            # NOR Gate
            print("\nEnter two 1-bit numbers for NOR Gate (0 or 1):")
            try:
                a = int(input("A: "))
                b = int(input("B: "))
                if a not in (0, 1) or b not in (0, 1):
                    print("Inputs must be 0 or 1")
                    continue
                show_nor_gate(a, b)
                adv = input("Show advanced details (truth table, K-map, SOP)? (y/n): ").strip().lower()
                if adv == "y":
                    print("\n--- Advanced Details for NOR Gate ---")
                    print("Truth Table:")
                    print("A B | NOR")
                    print("0 0 |  1")
                    print("0 1 |  0")
                    print("1 0 |  0")
                    print("1 1 |  0")
                    print("\nK-map for NOR Gate:")
                    print("      B=0   B=1")
                    print("A=0:   1     0")
                    print("A=1:   0     0")
                    print("\nSum of Products (SOP) Expression:")
                    print("Output = A' B'")
            except ValueError:
                print("Invalid input")

        elif choice == "7":
            # NAND Gate
            print("\nEnter two 1-bit numbers for NAND Gate (0 or 1):")
            try:
                a = int(input("A: "))
                b = int(input("B: "))
                if a not in (0, 1) or b not in (0, 1):
                    print("Inputs must be 0 or 1")
                    continue
                show_nand_gate(a, b)
                adv = input("Show advanced details (truth table, K-map, SOP)? (y/n): ").strip().lower()
                if adv == "y":
                    print("\n--- Advanced Details for NAND Gate ---")
                    print("Truth Table:")
                    print("A B | NAND")
                    print("0 0 |  1")
                    print("0 1 |  1")
                    print("1 0 |  1")
                    print("1 1 |  0")
                    print("\nK-map for NAND Gate:")
                    print("      B=0   B=1")
                    print("A=0:   1     1")
                    print("A=1:   1     0")
                    print("\nSum of Products (SOP) Expression:")
                    print("Output = A'B' + A'B + AB'")
            except ValueError:
                print("Invalid input")

        elif choice == "8":
            # XNOR Gate
            print("\nEnter two 1-bit numbers for XNOR Gate (0 or 1):")
            try:
                a = int(input("A: "))
                b = int(input("B: "))
                if a not in (0, 1) or b not in (0, 1):
                    print("Inputs must be 0 or 1")
                    continue
                show_xnor_gate(a, b)
                adv = input("Show advanced details (truth table, K-map, SOP)? (y/n): ").strip().lower()
                if adv == "y":
                    print("\n--- Advanced Details for XNOR Gate ---")
                    print("Truth Table:")
                    print("A B | XNOR")
                    print("0 0 |  1")
                    print("0 1 |  0")
                    print("1 0 |  0")
                    print("1 1 |  1")
                    print("\nK-map for XNOR Gate:")
                    print("      B=0   B=1")
                    print("A=0:   1     0")
                    print("A=1:   0     1")
                    print("\nSum of Products (SOP) Expression:")
                    print("Output = A'B' + AB")
            except ValueError:
                print("Invalid input")

        elif choice == "9":
            # Dynamic Circuit Builder
            dynamic_circuit_builder()

        elif choice == "10":
            break

        else:
            print("Invalid choice")

        input("\nPress Enter to continue...")

# -----------------------------------------
# Additional Gate Visualizations
# -----------------------------------------

def show_not_gate(a: int) -> None:
    """Visualize a NOT gate circuit with input and output."""
    result = 1 if a == 0 else 0
    print("\n=== NOT Gate Circuit ===")
    print(f"Input:  A = {a}")
    print("\nCircuit Diagram:")
    print("     A─────►NOT─────►Output")
    print("\nGate Operation:")
    print(f"NOT Gate: ¬{a} = {result}")
    print("\nOutput:")
    print(f"Result: {result}")

    print("\nK-map for NOT Gate:")
    print("A | NOT A")
    print("0 | 1")
    print("1 | 0")

def show_or_gate(a: int, b: int) -> None:
    """Visualize an OR gate circuit with inputs and output."""
    result = a | b
    print("\n=== OR Gate Circuit ===")
    print(f"Inputs:  A = {a}, B = {b}")
    print("\nCircuit Diagram:")
    print("     A─────┐")
    print("           ├────►OR─────►Output")
    print("     B─────┘")
    print("\nGate Operation:")
    print(f"OR Gate: {a} ∨ {b} = {result}")
    print("\nOutput:")
    print(f"Result: {result}")

    print("\nK-map for OR Gate:")
    print("      B=0   B=1")
    print("A=0:   0     1")
    print("A=1:   1     1")

def show_nor_gate(a: int, b: int) -> None:
    """Visualize a NOR gate circuit with inputs and output."""
    result = 1 if (a | b) == 0 else 0
    print("\n=== NOR Gate Circuit ===")
    print(f"Inputs:  A = {a}, B = {b}")
    print("\nCircuit Diagram:")
    print("     A─────┐")
    print("           ├────►NOR─────►Output")
    print("     B─────┘")
    print("\nGate Operation:")
    print(f"NOR Gate: ¬({a} ∨ {b}) = {result}")
    print("\nOutput:")
    print(f"Result: {result}")

    print("\nK-map for NOR Gate:")
    print("      B=0   B=1")
    print("A=0:   1     0")
    print("A=1:   0     0")

def show_nand_gate(a: int, b: int) -> None:
    """Visualize a NAND gate circuit with inputs and output."""
    result = 0 if (a & b) == 1 else 1
    print("\n=== NAND Gate Circuit ===")
    print(f"Inputs:  A = {a}, B = {b}")
    print("\nCircuit Diagram:")
    print("     A─────┐")
    print("           ├────►NAND────►Output")
    print("     B─────┘")
    print("\nGate Operation:")
    print(f"NAND Gate: ¬({a} ∧ {b}) = {result}")
    print("\nOutput:")
    print(f"Result: {result}")

    print("\nK-map for NAND Gate:")
    print("      B=0   B=1")
    print("A=0:   1     1")
    print("A=1:   1     0")

def show_xnor_gate(a: int, b: int) -> None:
    """Visualize an XNOR gate circuit with inputs and output."""
    result = 1 if a == b else 0
    print("\n=== XNOR Gate Circuit ===")
    print(f"Inputs:  A = {a}, B = {b}")
    print("\nCircuit Diagram:")
    print("     A─────┐")
    print("           ├────►XNOR────►Output")
    print("     B─────┘")
    print("\nGate Operation:")
    print(f"XNOR Gate: {a} XNOR {b} = {result}")
    print("\nOutput:")
    print(f"Result: {result}")

    print("\nK-map for XNOR Gate:")
    print("      B=0   B=1")
    print("A=0:   1     0")
    print("A=1:   0     1")

# -----------------------------------------------------------------------------
# Dynamic Circuit Builder Implementation
# -----------------------------------------------------------------------------

def compute_gate(gate: str, inputs: list) -> int:
    """Compute the output for a given gate and its inputs."""
    if gate.upper() == "NOT":
        return 1 if inputs[0] == 0 else 0
    elif gate.upper() == "OR":
        return inputs[0] | inputs[1]
    elif gate.upper() == "NOR":
        return 1 if (inputs[0] | inputs[1]) == 0 else 0
    elif gate.upper() == "NAND":
        return 0 if (inputs[0] & inputs[1]) == 1 else 1
    elif gate.upper() == "XNOR":
        return 1 if inputs[0] == inputs[1] else 0
    else:
        return None


def generate_advanced_details(gate: str) -> str:
    """Generate advanced details for a given gate type."""
    gate = gate.upper()
    if gate == "NOT":
        return ("Truth Table:\nA | NOT A\n0 | 1\n1 | 0\n\n"
                "K-map (1 variable):\n[A=0]: 1\n[A=1]: 0\n\n"
                "SOP Expression:\nOutput = A' (True when A=0)")
    elif gate == "OR":
        return ("Truth Table:\nA B | A OR B\n0 0 | 0\n0 1 | 1\n1 0 | 1\n1 1 | 1\n\n"
                "K-map:\n      B=0   B=1\nA=0:   0     1\nA=1:   1     1\n\n"
                "SOP Expression:\nOutput = A + B")
    elif gate == "NOR":
        return ("Truth Table:\nA B | NOR\n0 0 | 1\n0 1 | 0\n1 0 | 0\n1 1 | 0\n\n"
                "K-map:\n      B=0   B=1\nA=0:   1     0\nA=1:   0     0\n\n"
                "SOP Expression:\nOutput = A' B'")
    elif gate == "NAND":
        return ("Truth Table:\nA B | NAND\n0 0 | 1\n0 1 | 1\n1 0 | 1\n1 1 | 0\n\n"
                "K-map:\n      B=0   B=1\nA=0:   1     1\nA=1:   1     0\n\n"
                "SOP Expression:\nOutput = A'B' + A'B + AB'")
    elif gate == "XNOR":
        return ("Truth Table:\nA B | XNOR\n0 0 | 1\n0 1 | 0\n1 0 | 0\n1 1 | 1\n\n"
                "K-map:\n      B=0   B=1\nA=0:   1     0\nA=1:   0     1\n\n"
                "SOP Expression:\nOutput = A'B' + AB")
    else:
        return "No advanced details available."


def dynamic_circuit_builder() -> None:
    """Interactive dynamic circuit builder for gate operations."""
    circuit_components = []  # List to hold components; each component is a dict
    component_counter = 1

    advanced_mode = False
    enable_adv = input("Enable Advanced Dynamic Builder Mode? (y/n): ").strip().lower()
    if enable_adv == "y":
        advanced_mode = True
        print("Advanced Mode enabled.")
    else:
        print("Advanced Mode disabled.")

    def show_full_circuit():
        print("\n--- Full Circuit Diagram ---")
        if not circuit_components:
            print("[Empty Circuit]")
        else:
            if advanced_mode:
                diagram = "Input "
                for comp in circuit_components:
                    bw = comp.get('bit_width', 1)
                    diagram += f"--[{comp['gate']} ({bw}-bit)]--> "
                diagram += "Output"
                print(diagram)
            else:
                for comp in circuit_components:
                    print(f"[{comp['id']}] {comp['gate']}(inputs={comp['inputs']}) => {comp['output']}")

    # New nested function to display a simple K-map for the current gate chain
    def print_kmap_for_chain(components: list) -> None:
        print("\n--- K-map for Current Gate Chain ---")
        print("| ID | Gate   | Inputs        | Output |")
        print("|----|--------|---------------|--------|")
        for comp in components:
            print(f"| {comp['id']}  | {comp['gate']} | {comp['inputs']} | {comp['output']} |")
        print("-----------------------------------------")

    # Entering dynamic builder mode
    print("\nEntering Dynamic Circuit Builder Mode.")
    print("Type 'help' for a list of commands.")

    while True:
        cmd = input("Dynamic Builder > ").strip()
        if not cmd:
            continue
        parts = cmd.split()
        command = parts[0].lower()

        if command == "help":
            print("Available commands:")
            print("  add [GATE]       -> Add a new gate (NOT, OR, NOR, NAND, XNOR)")
            print("  custom [NAME]    -> Create a custom gate with a truth table")
            print("  list             -> List all circuit components with details")
            print("  delete [ID]      -> Delete a component by ID")
            print("  edit [ID]        -> Edit a component's inputs and bit width (if advanced)")
            print("  move [ID] [POS]  -> Move component to new position (starting at 1)")
            print("  move_rc [ID] [row] [column]  -> Move component using row & column (fixed 3 columns per row)")
            print("  show             -> Display full circuit diagram")
            print("  kmap             -> Display K-map for current gate chain")
            print("  advanced [ID]    -> Show advanced details for a component")
            print("  save [filename]  -> Save current circuit to file")
            print("  load [filename]  -> Load circuit from file")
            print("  exit             -> Exit dynamic builder mode")
            continue

        elif command == "add":
            if len(parts) < 2:
                print("Usage: add [GATE]")
                continue
            gate_type = parts[1].upper()
            if gate_type not in ["NOT", "OR", "NOR", "NAND", "XNOR"]:
                print("Invalid gate type. Valid types: NOT, OR, NOR, NAND, XNOR")
                continue
            try:
                inputs = []
                if gate_type == "NOT":
                    val = int(input("Enter 1-bit input for NOT Gate (0 or 1): "))
                    if val not in (0, 1):
                        print("Invalid input. Must be 0 or 1.")
                        continue
                    inputs.append(val)
                else:
                    val1 = int(input(f"Enter first 1-bit input for {gate_type} Gate (0 or 1): "))
                    val2 = int(input(f"Enter second 1-bit input for {gate_type} Gate (0 or 1): "))
                    if val1 not in (0, 1) or val2 not in (0, 1):
                        print("Invalid inputs. Must be 0 or 1.")
                        continue
                    inputs.extend([val1, val2])

                output = compute_gate(gate_type, inputs)
                adv_details = generate_advanced_details(gate_type)

                if advanced_mode:
                    bit_input = input(f"Recommended bit width for {gate_type} gate is 1-bit. Press Enter to use default or specify bit width: ").strip()
                    if bit_input == "":
                        bit_width = 1
                    else:
                        try:
                            bit_width = int(bit_input)
                        except ValueError:
                            print("Invalid bit width input. Defaulting to 1-bit.")
                            bit_width = 1
                    component = {
                        'id': component_counter,
                        'gate': gate_type,
                        'inputs': inputs,
                        'output': output,
                        'bit_width': bit_width,
                        'advanced': adv_details
                    }
                else:
                    component = {
                        'id': component_counter,
                        'gate': gate_type,
                        'inputs': inputs,
                        'output': output,
                        'advanced': adv_details
                    }
                circuit_components.append(component)
                print(f"Component added with ID {component_counter}.")
                component_counter += 1
                show_full_circuit()
            except ValueError:
                print("Invalid input. Please enter integer values (0 or 1).")

        elif command == "delete":
            if len(parts) < 2:
                print("Usage: delete [ID]")
                continue
            try:
                comp_id = int(parts[1])
                new_components = [c for c in circuit_components if c['id'] != comp_id]
                if len(new_components) == len(circuit_components):
                    print(f"No component with ID {comp_id} found.")
                else:
                    circuit_components[:] = new_components
                    print(f"Component {comp_id} deleted.")
                    show_full_circuit()
            except ValueError:
                print("Invalid ID.")

        elif command == "edit":
            if len(parts) < 2:
                print("Usage: edit [ID]")
                continue
            try:
                comp_id = int(parts[1])
                comp = next((c for c in circuit_components if c['id'] == comp_id), None)
                if not comp:
                    print(f"No component with ID {comp_id} found.")
                    continue
                gate_type = comp.get('gate')
                inputs = []
                if gate_type == "NOT":
                    val = int(input("Enter new 1-bit input for NOT Gate (0 or 1): "))
                    if val not in (0, 1):
                        print("Invalid input.")
                        continue
                    inputs.append(val)
                else:
                    val1 = int(input(f"Enter new first 1-bit input for {gate_type} Gate (0 or 1): "))
                    val2 = int(input(f"Enter new second 1-bit input for {gate_type} Gate (0 or 1): "))
                    if val1 not in (0, 1) or val2 not in (0, 1):
                        print("Invalid inputs.")
                        continue
                    inputs.extend([val1, val2])
                comp['inputs'] = inputs
                if comp.get('type') == 'CUSTOM':
                    idx = int(''.join(str(bit) for bit in inputs), 2)
                    comp['output'] = comp['truth_table'][idx]
                else:
                    comp['output'] = compute_gate(gate_type, inputs)
                if advanced_mode and comp.get('bit_width') is not None:
                    update_bw = input("Do you want to update the bit width? (y/n): ").strip().lower()
                    if update_bw == "y":
                        bit_input = input("Enter new bit width: ").strip()
                        try:
                            comp['bit_width'] = int(bit_input)
                        except ValueError:
                            print("Invalid input. Bit width unchanged.")
                print(f"Component {comp_id} updated.")
                show_full_circuit()
            except ValueError:
                print("Invalid input.")

        elif command == "move":
            if len(parts) < 3:
                print("Usage: move [ID] [new_position]")
                continue
            try:
                comp_id = int(parts[1])
                new_pos = int(parts[2]) - 1
                idx = next((i for i, c in enumerate(circuit_components) if c['id'] == comp_id), None)
                if idx is None:
                    print(f"No component with ID {comp_id} found.")
                    continue
                comp = circuit_components.pop(idx)
                if new_pos < 0 or new_pos > len(circuit_components):
                    print("Invalid new position.")
                    circuit_components.insert(idx, comp)  # revert
                    continue
                circuit_components.insert(new_pos, comp)
                print(f"Component {comp_id} moved to position {new_pos + 1}.")
                show_full_circuit()
            except ValueError:
                print("Invalid input.")

        elif command == "move_rc":
            if len(parts) < 4:
                print("Usage: move_rc [ID] [row] [column]")
                continue
            try:
                comp_id = int(parts[1])
                row = int(parts[2])
                col = int(parts[3])
                fixed_cols = 3  # each row has 3 columns
                new_pos = (row - 1) * fixed_cols + (col - 1)
                idx = next((i for i, c in enumerate(circuit_components) if c['id'] == comp_id), None)
                if idx is None:
                    print(f"No component with ID {comp_id} found.")
                    continue
                comp = circuit_components.pop(idx)
                if new_pos < 0:
                    print("Invalid position calculated.")
                    circuit_components.insert(idx, comp)  # revert
                    continue
                if new_pos > len(circuit_components):
                    new_pos = len(circuit_components)
                circuit_components.insert(new_pos, comp)
                print(f"Component {comp_id} moved to row {row}, column {col} (position {new_pos + 1}).")
                show_full_circuit()
            except ValueError:
                print("Invalid input.")

        elif command == "kmap":
            print_kmap_for_chain(circuit_components)

        elif command == "list":
            print("\nCurrent Circuit Components:")
            for comp in circuit_components:
                extra = f", Bit Width: {comp.get('bit_width', 'N/A')}" if 'bit_width' in comp else ""
                custom_info = " [Custom]" if comp.get('type') == 'CUSTOM' else ""
                print(f"ID: {comp['id']} | Gate: {comp['gate']}{custom_info} | Inputs: {comp['inputs']} | Output: {comp['output']}{extra}")

        elif command == "show":
            show_full_circuit()

        elif command == "advanced":
            if len(parts) < 2:
                print("Usage: advanced [ID]")
                continue
            try:
                comp_id = int(parts[1])
                comp = next((c for c in circuit_components if c['id'] == comp_id), None)
                if not comp:
                    print(f"No component with ID {comp_id} found.")
                    continue
                print(f"\n--- Advanced Details for Component {comp_id} ({comp['gate']}) ---")
                print(comp['advanced'])
            except ValueError:
                print("Invalid ID.")

        elif command == "save":
            if len(parts) < 2:
                print("Usage: save [filename]")
                continue
            filename = parts[1]
            try:
                import json
                with open(filename, 'w') as f:
                    json.dump(circuit_components, f)
                print(f"Circuit components saved to {filename}.")
                show_full_circuit()
            except Exception as e:
                print(f"Error saving file: {e}")

        elif command == "load":
            if len(parts) < 2:
                print("Usage: load [filename]")
                continue
            filename = parts[1]
            try:
                import json
                with open(filename, 'r') as f:
                    loaded = json.load(f)
                circuit_components[:] = loaded
                if circuit_components:
                    component_counter = max(comp['id'] for comp in circuit_components) + 1
                else:
                    component_counter = 1
                print(f"Circuit components loaded from {filename}.")
                show_full_circuit()
            except Exception as e:
                print(f"Error loading file: {e}")

        elif command == "custom":
            try:
                if len(parts) < 2:
                    custom_name = input("Enter a name for your custom gate: ").strip()
                else:
                    custom_name = parts[1]
                n_inputs = int(input("Enter number of inputs for the custom gate: "))
                expected_entries = 2 ** n_inputs
                print(f"Enter truth table outputs for each combination in order (total {expected_entries} entries).")
                method_choice = input("Enter '1' for single-line input (space-separated) or '2' for multi-line input: ").strip()
                if method_choice == '1':
                    truth_entries_raw = input("Enter the truth table outputs separated by spaces: ").split()
                elif method_choice == '2':
                    truth_entries_raw = []
                    print(f"Enter {expected_entries} truth table outputs (one per line):")
                    for i in range(expected_entries):
                        entry = input(f"Entry {i+1}: ").strip()
                        truth_entries_raw.append(entry)
                else:
                    print("Invalid input method choice. Aborting custom gate creation.")
                    continue
                if len(truth_entries_raw) != expected_entries:
                    print("Incorrect number of truth table entries.")
                    continue
                truth_entries = [int(x) for x in truth_entries_raw]
                inputs = []
                for i in range(n_inputs):
                    val = int(input(f"Enter 1-bit input {i+1}: "))
                    if val not in (0,1):
                        print("Invalid input.")
                        break
                    inputs.append(val)
                else:
                    idx = int(''.join(str(bit) for bit in inputs), 2)
                    output = truth_entries[idx]
                    adv_details = f"Custom gate truth table: {truth_entries}"
                    if advanced_mode:
                        bit_input = input(f"Recommended bit width for custom gate {custom_name} is 1-bit. Press Enter to use default or specify bit width: ").strip()
                        if bit_input == "":
                            bit_width = 1
                        else:
                            try:
                                bit_width = int(bit_input)
                            except ValueError:
                                print("Invalid bit width input. Defaulting to 1-bit.")
                                bit_width = 1
                        component = {
                            'id': component_counter,
                            'gate': custom_name,
                            'type': 'CUSTOM',
                            'inputs': inputs,
                            'output': output,
                            'bit_width': bit_width,
                            'truth_table': truth_entries,
                            'n_inputs': n_inputs,
                            'advanced': adv_details
                        }
                    else:
                        component = {
                            'id': component_counter,
                            'gate': custom_name,
                            'type': 'CUSTOM',
                            'inputs': inputs,
                            'output': output,
                            'truth_table': truth_entries,
                            'n_inputs': n_inputs,
                            'advanced': adv_details
                        }
                    circuit_components.append(component)
                    print(f"Custom component added with ID {component_counter}.")
                    component_counter += 1
                    show_full_circuit()
            except ValueError:
                print("Invalid input in custom gate creation.")

        elif command == "exit":
            print("Exiting Dynamic Circuit Builder Mode.")
            break
        else:
            print("Unknown command. Type 'help' for a list of commands.")

    # End of dynamic circuit builder loop

# -----------------------------------------

# ---- END OF circuit_visualization.py ----


# ---- START OF signed_representations.py ----

# =========================================
# File: signed_representations.py
# Description:
#   Visualization of different signed number representations
#   and overflow detection.
# =========================================

from typing import Tuple

def show_number_representations(value: int, bits: int = 8) -> None:
    """Show different signed number representations."""
    print(f"\n=== Signed Number Representations ({bits}-bit) ===")
    print(f"Decimal value: {value}")
    
    # Calculate ranges
    max_unsigned = (1 << bits) - 1
    max_signed = (1 << (bits - 1)) - 1
    min_signed = -(1 << (bits - 1))
    
    # Check for overflow
    if abs(value) > max_signed:
        print(f"\nWarning: Value {value} exceeds {bits}-bit signed range [{min_signed}, {max_signed}]")
        print("Results below show wrapped/modulo behavior")
    
    # Unsigned representation (for comparison)
    unsigned_pattern = format(value & ((1 << bits) - 1), f'0{bits}b')
    print(f"\nUnsigned binary:  {unsigned_pattern}")
    print(f"Unsigned decimal: {int(unsigned_pattern, 2)}")
    
    # Sign-magnitude representation
    sign_bit = '1' if value < 0 else '0'
    magnitude = format(abs(value) & ((1 << (bits-1)) - 1), f'0{bits-1}b')
    sign_magnitude = sign_bit + magnitude
    print(f"\nSign-magnitude:")
    print(f"Binary:  {sign_bit} {magnitude}")
    print(f"         │ └─ Magnitude bits")
    print(f"         └─── Sign bit (0=positive, 1=negative)")
    
    # One's complement
    if value < 0:
        ones_complement = ''.join('1' if b == '0' else '0' for b in format(abs(value), f'0{bits}b'))
    else:
        ones_complement = format(value, f'0{bits}b')
    print(f"\nOne's complement:")
    print(f"Binary:  {ones_complement}")
    if value < 0:
        print("(Inverted all bits of positive number)")
    
    # Two's complement
    if value < 0:
        twos_complement = format((1 << bits) + value, f'0{bits}b')
    else:
        twos_complement = format(value, f'0{bits}b')
    print(f"\nTwo's complement:")
    print(f"Binary:  {twos_complement}")
    if value < 0:
        print("(One's complement + 1)")
    
    # Show ranges
    print(f"\nValid ranges for {bits}-bit numbers:")
    print(f"Unsigned:        0 to {max_unsigned}")
    print(f"Sign-magnitude: -{max_signed} to {max_signed}")
    print(f"One's complement: -{max_signed} to {max_signed}")
    print(f"Two's complement: {min_signed} to {max_signed}")

def check_overflow(a: int, b: int, result: int, bits: int = 8, operation: str = 'add') -> Tuple[bool, str]:
    """Check for overflow in arithmetic operations."""
    max_val = (1 << (bits - 1)) - 1
    min_val = -(1 << (bits - 1))
    
    if operation == 'add':
        # Overflow in addition occurs when:
        # 1. Both numbers are positive but sum exceeds max_val
        # 2. Both numbers are negative but sum is less than min_val
        if (a > 0 and b > 0 and result > max_val) or \
           (a < 0 and b < 0 and result < min_val):
            return True, f"Result {result} exceeds {bits}-bit signed range [{min_val}, {max_val}]"
    elif operation == 'subtract':
        # Overflow in subtraction occurs when:
        # 1. First number is positive, second is negative, and result exceeds max_val
        # 2. First number is negative, second is positive, and result is less than min_val
        if (a > 0 and b < 0 and result > max_val) or \
           (a < 0 and b > 0 and result < min_val):
            return True, f"Result {result} exceeds {bits}-bit signed range [{min_val}, {max_val}]"
    elif operation == 'multiply':
        # For multiplication, we need to check:
        # 1. If result exceeds the bit width (simple check)
        # 2. For signed numbers, check sign rules
        if result < min_val or result > max_val:
            msg = f"Multiplication result {result} exceeds {bits}-bit range [{min_val}, {max_val}]"
            # Add sign analysis
            if (a < 0 and b < 0 and result < 0) or \
               (a > 0 and b > 0 and result < 0) or \
               (a * b > 0 and result < 0):
                msg += "\nSign error: incorrect sign in result"
            return True, msg
    elif operation == 'divide':
        # For division, we need to check:
        # 1. Division by zero (should be caught earlier)
        # 2. Special case: MIN_INT / -1 (results in overflow due to two's complement)
        if b == 0:
            return True, "Division by zero"
        elif a == min_val and b == -1:
            return True, f"Special case overflow: {min_val} / -1 exceeds {bits}-bit range"
        elif result < min_val or result > max_val:
            return True, f"Division result {result} exceeds {bits}-bit range [{min_val}, {max_val}]"
    
    return False, ""

def show_carry_chain(a: str, b: str, operation: str = 'add') -> None:
    """Visualize carry/borrow chain in binary arithmetic."""
    print("\nCarry Chain Visualization:")
    print("  " + " ".join(a))  # First number
    print(f"{'+ ' if operation == 'add' else '- '}" + " ".join(b))  # Second number
    print("  " + "-" * (len(a) * 2 - 1))  # Separator line
    
    carries = []
    result = []
    carry = 0
    
    if operation == 'add':
        # Process addition from right to left
        for i in range(len(a)-1, -1, -1):
            bit_sum = int(a[i]) + int(b[i]) + carry
            carries.append(bit_sum // 2)
            result.append(str(bit_sum % 2))
            carry = bit_sum // 2
    else:
        # Process subtraction (using two's complement)
        b_complement = ''.join('1' if bit == '0' else '0' for bit in b)
        carry = 1
        for i in range(len(b_complement)-1, -1, -1):
            bit_sum = int(b_complement[i]) + carry
            b_complement = b_complement[:i] + str(bit_sum % 2) + b_complement[i+1:]
            carry = bit_sum // 2
        
        # Now add a and b_complement
        carry = 0
        for i in range(len(a)-1, -1, -1):
            bit_sum = int(a[i]) + int(b_complement[i]) + carry
            carries.append(bit_sum // 2)
            result.append(str(bit_sum % 2))
            carry = bit_sum // 2
    
    # Show carries
    carries.reverse()
    result.reverse()
    if any(carries):
        print("  " + " ".join(str(c) for c in carries) + "  ← Carries")
    print("  " + " ".join(result) + "  ← Result")

def show_overflow_cases(bits: int = 4) -> None:
    """Demonstrate common overflow scenarios with visual explanations."""
    print(f"\n=== Overflow Demonstration ({bits}-bit numbers) ===")
    
    # Calculate ranges
    max_val = (1 << (bits - 1)) - 1
    min_val = -(1 << (bits - 1))
    
    print(f"\nValid ranges for {bits}-bit signed numbers:")
    print(f"Maximum positive: {max_val:4} = {format(max_val, f'0{bits}b')}")
    print(f"Minimum negative: {min_val:4} = {format((1 << bits) + min_val, f'0{bits}b')}")
    
    # Case 1: Maximum positive + 1
    print("\n1. Maximum Positive + 1 Overflow:")
    a, b = max_val, 1
    result = a + b
    print(f"   {a:4} + {b:4} = {result:4}")
    print(f"   {format(a, f'0{bits}b')} (max positive)")
    print(f" + {format(b, f'0{bits}b')}")
    print(f"   {'-' * bits}")
    result_bin = format(result & ((1 << bits) - 1), f'0{bits}b')
    print(f"   {result_bin} (wraps to negative!)")
    
    # Case 2: Minimum negative - 1
    print("\n2. Minimum Negative - 1 Overflow:")
    a, b = min_val, -1
    result = a + b
    print(f"   {a:4} + {b:4} = {result:4}")
    print(f"   {format((1 << bits) + a, f'0{bits}b')} (min negative)")
    print(f" + {format((1 << bits) + b, f'0{bits}b')} (-1 in two's complement)")
    print(f"   {'-' * bits}")
    result_bin = format(result & ((1 << bits) - 1), f'0{bits}b')
    print(f"   {result_bin} (wraps to positive!)")
    
    # Case 3: Positive + Positive → Negative
    print("\n3. Positive + Positive → Negative Overflow:")
    a = max_val - 1
    b = 3
    result = a + b
    print(f"   {a:4} + {b:4} = {result:4}")
    print(f"   {format(a, f'0{bits}b')}")
    print(f" + {format(b, f'0{bits}b')}")
    print(f"   {'-' * bits}")
    result_bin = format(result & ((1 << bits) - 1), f'0{bits}b')
    print(f"   {result_bin} (result appears negative)")
    
    # Case 4: Negative + Negative → Positive
    print("\n4. Negative + Negative → Positive Overflow:")
    a = min_val + 1
    b = -3
    result = a + b
    print(f"   {a:4} + {b:4} = {result:4}")
    print(f"   {format((1 << bits) + a, f'0{bits}b')}")
    print(f" + {format((1 << bits) + b, f'0{bits}b')}")
    print(f"   {'-' * bits}")
    result_bin = format(result & ((1 << bits) - 1), f'0{bits}b')
    print(f"   {result_bin} (result appears positive)")
    
    # Case 5: Multiplication Overflow
    print("\n5. Multiplication Overflow:")
    a = max_val // 2
    b = 3
    result = a * b
    print(f"   {a:4} × {b:4} = {result:4}")
    print(f"   {format(a, f'0{bits}b')} × {format(b, f'0{bits}b')}")
    print(f"   {'-' * bits}")
    result_bin = format(result & ((1 << bits) - 1), f'0{bits}b')
    print(f"   {result_bin} (truncated result)")
    
    # Case 6: Special Division Overflow (MIN_INT / -1)
    print("\n6. Special Division Case (MIN_INT ÷ -1):")
    a = min_val
    b = -1
    try:
        result = a // b
        print(f"   {a:4} ÷ {b:4} = {result:4}")
        print(f"   {format((1 << bits) + a, f'0{bits}b')} ÷ {format((1 << bits) + b, f'0{bits}b')}")
        print("   This causes overflow because the positive result exceeds the maximum positive value")
    except ZeroDivisionError:
        print("   Division by zero") 

# ---- END OF signed_representations.py ----


# ---- START OF number_conversion.py ----

# number_conversion.mojo

# Alias or define a Float type if needed
# (Earliest Mojo doesn't have a built-in 'Float' type like Python)
type Float = Float64  # or use 'Python.Float' if bridging to Python

# 1) POWER-OF-2 TABLE
def create_power_table(decimal_value: Int, max_exponent: Int = 10) -> None:
    # Prints a markdown-style table from 2^max_exponent down to 2^0
    print("| Power (2^n) | Value | Fits? | Binary Bit |")
    print("|---|---|---|---|")

    var remainder = decimal_value
    for n in range(max_exponent, -1, -1):
        let power_value = (1 << n)  # 2^n
        if power_value <= remainder:
            let leftover = remainder - power_value
            print("| 2^" + str(n) + " | " + str(power_value) + 
                  " | Yes (leftover=" + str(leftover) + ") | 1 |")
            remainder = leftover
        else:
            print("| 2^" + str(n) + " | " + str(power_value) + 
                  " | No | 0 |")

# 2) DECIMAL <-> BINARY
def decimal_to_binary(decimal_value: int, bit_length: int = 32) -> str:
    """
    Converts a decimal number to its binary representation.
    Uses two's complement for negative numbers.
    """
    if decimal_value >= 0:
        return format(decimal_value, "0" + str(bit_length) + "b")
    else:
        positive_value = -decimal_value
        if positive_value >= (1 << bit_length):
            raise ValueError("Value too negative for the provided bit length.")
        bin_pos = format(positive_value, "0" + str(bit_length) + "b")
        inverted_bits = ""
        for bit in bin_pos:
            if bit == '0':
                inverted_bits += '1'
            else:
                inverted_bits += '0'
        twos_comp_int = int(inverted_bits, base=2) + 1
        twos_comp_str = format(twos_comp_int, "0" + str(bit_length) + "b")
        return twos_comp_str

def binary_to_decimal(binary_str: str) -> int:
    """
    Converts a binary string to its decimal representation.
    Interprets two's complement if the leftmost bit is 1.
    """
    bit_length = len(binary_str)
    if len(binary_str) == 0:
        raise ValueError("Empty binary string")

    if binary_str[0] == '0':
        return int(binary_str, base=2)
    else:
        inverted_bits = ""
        for bit in binary_str:
            if bit == '1':
                inverted_bits += '0'
            else:
                inverted_bits += '1'
        positive_part = int(inverted_bits, base=2) + 1
        return -positive_part

# 3) DECIMAL <-> HEX
def decimal_to_hex(decimal_value: Int) -> String:
    if decimal_value >= 0:
        return hex(decimal_value)[2:]
    else:
        return "-" + hex(-decimal_value)[2:]

def hex_to_decimal(hex_str: String) -> Int raises:
    if len(hex_str) == 0:
        raise ValueError("Empty hex string")

    if hex_str.startswith("-"):
        return -(int(hex_str[1:], base=16))
    else:
        return int(hex_str, base=16)

# 4) OPTIONAL FLOAT->IEEE 754 (SINGLE PRECISION)
#    If we want to call Python's 'struct', do:
from Python import import_module
struct = import_module("struct")  # this might raise
def float_to_ieee754_single(value: Float) raises -> String:
    # Pseudocode for single-precision
    # We'll assume a "float" is stored in 'value'
    let pack_result = struct.invoke("pack", [">f", value])  # may raise
    let raw_tuple = struct.invoke("unpack", [">I", pack_result])  # may raise
    # raw_tuple is a 1-element tuple => raw_int
    let raw_int = raw_tuple[0]
    return format(raw_int, "032b")

def ieee754_single_to_float(ieee_binary: String) raises -> Float:
    let raw_int = int(ieee_binary, base=2)  # may raise
    let pack_bytes = struct.invoke("pack", [">I", raw_int])  # may raise
    let float_tuple = struct.invoke("unpack", [">f", pack_bytes])  # may raise
    return float_tuple[0]

# 5) FRACTION -> BINARY
def fraction_to_binary(fraction: Float, max_bits: Int = 8) -> String:
    if fraction < 0.0:
        raise ValueError("Fraction must be non-negative")

    var bits = ""
    var value = fraction
    for i in range(max_bits):
        value = value * 2.0
        if value >= 1.0:
            bits = bits + "1"
            value = value - 1.0
        else:
            bits = bits + "0"

        if value == 0.0:
            break
    return bits

# MAIN DEMO
def main() raises -> None:
    # 1) Table for integer part 11
    print("## Power-of-2 Table for 11")
    create_power_table(11, 10)
    print("")

    # 2) decimal -> binary -> decimal roundtrip
    var dec_val: Int = -42
    var bin_rep = decimal_to_binary(dec_val, 16)
    var roundtrip_dec = binary_to_decimal(bin_rep)  # may raise
    print("Decimal: " + str(dec_val) + 
          " -> Binary(16-bit): " + bin_rep + 
          " -> Back: " + str(roundtrip_dec))

    # 3) decimal -> hex -> decimal roundtrip
    var dec_hex_val: Int = 255
    var hex_rep = decimal_to_hex(dec_hex_val)
    var roundtrip_hex_dec = hex_to_decimal(hex_rep)  # may raise
    print("Decimal: " + str(dec_hex_val) +
          " -> Hex: " + hex_rep +
          " -> Back: " + str(roundtrip_hex_dec))

    # 4) Float -> IEEE 754 single -> float
    var fval: Float = -123.456
    var f_ieee = float_to_ieee754_single(fval)  # may raise
    var f_round = ieee754_single_to_float(f_ieee)  # may raise
    print("Float value: " + str(fval))
    print("IEEE754 single: " + f_ieee)
    print("Converted back: " + str(f_round))

    # 5) Fraction example for 0.25
    # integer = 11 -> binary=1011
    # fraction=0.25 -> 0.01 in binary
    var fraction_bits = fraction_to_binary(0.25, 8)
    print("Example 11.25 => integer=11 (binary=1011) + fraction=0.25 (binary=0." 
          + fraction_bits + ") => 1011." + fraction_bits)

# Uncomment the call to actually run:
# main()

# ---- END OF number_conversion.py ----

