<!-- Table of Contents -->

## Table of Contents
1. [Document Metadata](#document-metadata)
2. [Notation and Definitions](#notation-and-definitions)
3. [Design Implementation](#design-implementation)
   - [Possible Inputs](#possible-inputs)
   - [Truth Table Analysis](#truth-table)
   - [K-Map Reduction](#k-map-reduction)
   - [Gate Operations](#gate-operations)
4. [Circuit Analysis](#circuit-analysis)
   - [Circuit Diagram](#circuit-diagram-representation)
   - [Signal Analysis](#full-signal-analysis)
   - [Boolean Expression](#boolean-expression-reduction)
5. [Simulation and Testing](#simulation-and-results)
   - [Setup and Configuration](#simulation-and-results)
   - [Results Analysis](#simulation-results-anticipate)
   - [Troubleshooting](#troubleshooting-notes)
6. [References and Tools](#direct-links)
7. [Glossary](#glossary)

[DOCUMENT_METADATA]
title=Half Adder Design Documentation
version=11.0
date=2024-02-XX
author=Ryan Oates
Assignment=Lab_Two

[NOTATION_KEY] and [KEY DEFINITIONS]
GateSymbolNotation = "List of logic gate symbols used in this design (AND, OR, NOT, etc.)."
WireConnectionSymbols = "Notation for wires and connections in circuit diagrams (lines for connections, dots for junctions, labels/arrows for inputs/outputs)."
LogicLevelsRepresentation = "Using `1` (HIGH) and `0` (LOW) to denote binary logic levels."
BooleanExpressionNotation = "Use `+` for OR, `·` (or juxtaposition) for AND, and overbar or ! for NOT."

[VERIFICATION_CHECKLIST]
; Each item below should be checked (✔) or marked as ❌ if an issue is found:
verify_symbols_defined = (✔/❌) ; "All necessary gate symbols and wire notations are defined." (Comment: ...)
verify_logic_levels    = (✔/❌) ; "Logic 0/1 representation is clear and used consistently." (Comment: ...)
verify_notation_consistency = (✔/❌) ; "Boolean expression notation is consistent across all sections." (Comment: ...)


[Possible Inputs]
InputVariables = "List of input variable names, e.g., A, B, C."
InputDomain = "Binary domain {0,1} for each input; specify any don't-cares if relevant."
; Verification:
verify_all_inputs_listed = (✔/❌) ; (Comment: ...)
verify_domain_specified  = (✔/❌) ; (Comment: ...)
[Truth Table]
TruthTableInputs  = "Repeat input variables here as columns (A, B, ...)."
TruthTableOutputs = "Output variable(s) as columns (F, or Sum/Carry for half-adder)."
TruthTableFormat  = "Entries: use 0/1 as defined in [NOTATION_KEY]."
; Example:
; A | B || Sum | Carry
; 0 | 0 ||  0  |   0
; 0 | 1 ||  1  |   0
; 1 | 0 ||  1  |   0
; 1 | 1 ||  0  |   1
; Verification:
verify_all_combinations = (✔/❌) ; (Comment: ...)
verify_output_values    = (✔/❌) ; (Comment: ...)
verify_table_format     = (✔/❌) ; (Comment: ...)
[K-Map Reduction]
KMapVariables          = "Variables used (e.g., A,B,C)."
KMapLayout             = "Cell arrangement with Gray code (2x2, 4x4, etc.)."
KMapFilling            = "Assign 1/0 in cells per truth table outputs."
KMapGrouping           = "Group adjacent 1s (or 0s for POS) in powers of 2."
KMapSimplificationSteps= "Step-by-step derivation of minimal expression."
KMapResultExpression   = "Final simplified Boolean expression from the K-map."

; Verification:
verify_grouping_complete  = (✔/❌) ; (Comment: ...)
verify_minimal_expression = (✔/❌) ; (Comment: ...)
verify_expression_correct = (✔/❌) ; (Comment: ...)

[Gate Operations]
; Define logic gate implementation from the simplified expression:
Gate1 = "e.g., AND gate with inputs A,B -> output X."
Gate2 = "e.g., NOT gate with input C -> output Y."
Gate3 = "e.g., OR gate with inputs X,Y -> output F."

GateOperationNotes = "Assume ideal gates unless otherwise noted; small propagation delay present."

; Verification:
verify_gates_complete      = (✔/❌) ; (Comment: ...)
verify_output_consistency  = (✔/❌) ; (Comment: ...)
verify_notation_adherence  = (✔/❌) ; (Comment: ...)
verify_timing_addressed    = (✔/❌) ; (Comment: ...)

[Circuit Diagram Representation]
DiagramIllustration = "Reference or description of the schematic (or embedded image)."
DiagramNotation     = "Symbols/legends as per [NOTATION_KEY]."
DiagramLabels       = "Label inputs (A,B,...), outputs (F), and intermediate nodes (X,Y, etc.)."

; Verification:
verify_diagram_accuracy   = (✔/❌) ; (Comment: ...)
verify_label_consistency  = (✔/❌) ; (Comment: ...)
verify_symbol_standard    = (✔/❌) ; (Comment: ...)

[Full Signal Analysis]
NodeEquations      = "List Boolean eqns. for intermediate nodes (X = A·B, etc.)."
OutputEquation     = "Final output in terms of nodes or inputs."
PropagationSteps   = "Describe how signals propagate from inputs to outputs."
TimingAnalysis     = "Note critical path or propagation delay if relevant."

; Verification:
verify_node_logic         = (✔/❌) ; (Comment: ...)
verify_propagation_correctness = (✔/❌) ; (Comment: ...)
verify_timing_consistency = (✔/❌) ; (Comment: ...)

[SOP Reduction]
InitialSOP       = "Sum-of-Products expression from truth table minterms."
ReductionSteps   = "Algebraic manipulations combining terms via Boolean theorems."
ReducedSOP       = "Final minimized SOP expression."

; Verification:
verify_all_minterms_used  = (✔/❌) ; (Comment: ...)
verify_algebraic_steps    = (✔/❌) ; (Comment: ...)
verify_sop_matches_kmap   = (✔/❌) ; (Comment: ...)

[Boolean Expression Reduction]
InitialExpression      = "Starting Boolean formula (pre-simplification)."
TargetExpression       = "Final simplified form (goal)."
ReductionTechnique     = "Algebraic method, De Morgan's law, consensus theorem, etc."
ReductionProof         = "Proof or validation that both expressions are equivalent."
FinalBooleanExpression = "Final expression to implement."

; Verification:
verify_equivalence_proven = (✔/❌) ; (Comment: ...)
verify_expression_minimal  = (✔/❌) ; (Comment: ...)
verify_consistency_final   = (✔/❌) ; (Comment: ...)

[Direct Links]
NotationKey_related     = "Used by all sections for consistent symbols."
PossibleInputs_related  = "Defines domain for [Truth Table]."
TruthTable_related      = "Basis for K-Map, SOP, etc."
KMapReduction_related   = "Yields minimal expression from truth table."
GateOperations_related  = "Implements the simplified expression with gates."
CircuitDiagram_related  = "Visual representation of Gate Operations."
FullSignalAnalysis_related = "Verifies dynamic behavior vs. static truth table."
SOPReduction_related    = "Algebraic approach verifying K-Map result."
BooleanExprReduction_related = "Further proof of equivalence/minimality."
Glossary_related        = "Definitions of gates and terms used."

[Glossary]
AND Gate="Outputs 1 only if all inputs=1 (logical conjunction). Symbol: ∧ or ·"
OR Gate="Outputs 1 if at least one input=1 (logical disjunction). Symbol: ∨ or +"
NOT Gate="Outputs inverted logic level of input (logical negation). Symbol: ¬ or !"
Logic 1 (HIGH)="5V or boolean true."
Logic 0 (LOW)="0V or boolean false."
Truth Table="Exhaustive listing of inputs vs. output(s)."
Karnaugh Map (K-Map)="Graphical method to simplify Boolean expressions."
Sum-of-Products (SOP)="OR (sum) of multiple AND (product) terms."
Boolean Expression="Algebraic form with Boolean variables/operations."
Node (Intermediate)="Label for an internal signal or gate output."
Node Equation="Boolean formula for an intermediate node."
Propagation Delay="Time from input change to output change in logic."
Signal Propagation="Movement of logic level changes through gates."
Verification Checklist="List of design checks to ensure correctness."
Cross-Referencing="Pointing to related sections or terms in the doc."
✔ (Check mark)="Successful verification."
❌ (Cross mark)="Failure or issue found; requires correction."

[SIMULATION_AND_RESULTS]
simulation_tool=LTSpice
test_duration=100ns
input_stimulus="A: 0->1 at 20ns, 1->0 at 60ns; B: 0->1 at 40ns, 1->0 at 80ns"



[WAVEFORM_SETTINGS]
display_configuration="Signal colors, trace widths, background, grid, etc."

[SIMULATION_RESULTS ANTICIPATE
waveform_analysis="
Time    | A | B | Sum | Carry | Analysis
0-20ns  | 0 | 0 |  0  |   0   | Initial state
20-40ns | 1 | 0 |  1  |   0   | A transition
40-60ns | 1 | 1 |  0  |   1   | B transition, carry generated
60-80ns | 0 | 1 |  1  |   0   | A transition
80-100ns| 0 | 0 |  0  |   0   | Return to initial state
"

[VISUALIZATION_TIPS]
waveform_optimization="
1. Right-click signal name above graph to modify colors
2. Access Tools-->Settings-->Waveforms for trace width
3. Modify background via Tools-->Color preferences-->Waveform
4. Use RGB=255 for maximum visibility
"[TROUBLESHOOTING_NOTES]
initial_attempts="
1. First attempt used four inputs (redundant)
2. Issue with carry logic (initially included extraneous C input)
3. Resolved by generating carry solely from A,B
"[DESIGN_ITERATIONS]
version_history="
v1: Basic design with redundant inputs
v2: Removed redundant inputs
v3: Corrected carry generation
v4: Final optimized design with simulation verification
(Pending) v5: Next iteration with more thorough documentation
"

[NOTATION_AND_SYMBOLS]
; Consolidated gate definitions and symbols
NAND_definition="
symbol=⊼
truth_table:
   0 ⊼ 0 = 1
   0 ⊼ 1 = 1
   1 ⊼ 0 = 1
   1 ⊼ 1 = 0
implementation:
   A ⊼ B = (A•B)' (universal gate)
"AND_definition="
symbol=•
truth_table:
   0•0=0
   0•1=0
   1•0=0
   1•1=1
implementation:
   A • B = Logical AND
"OR_definition="
symbol=+
truth_table:
   0+0=0
   0+1=1
   1+0=1
   1+1=1
implementation:
   A + B = Logical OR
XOR_definition="
symbol=⊕
truth_table:
   0⊕0=0
   0⊕1=1
   1⊕0=1
   1⊕1=0
implementation:
   A⊕B=(A'B+AB')
NOT_definition="
symbol=' or ¬
truth_table:
   0'=1
   1'=0


implementation:
   A' = NOT A
circuit_symbols="
Wire = ─
Junction = ├
Turn = └ or ┌
Signal Flow = ►
Inversion (NOT) = ○
[COMPOUND_OPERATIONS]
half_adder="
Sum = A ⊕ B
Carry = A • B
full_adder="
Sum = A ⊕ B ⊕ Cin
Cout = (A • B) + ((A ⊕ B) • Cin)
[BOOLEAN_ALGEBRA_RULES]
demorgan="
(A + B)' = A' • B'
(A • B)' = A' + B'
distribution="
A•(B+C)=(A•B)+(A•C)
A+(B•C)=(A+B)•(A+C)
GateSymbolNotation = "AND (∧), OR (∨), NOT (¬), NAND (⊼), NOR (↓), etc."
WireConnectionSymbols = "Lines for signals (─), dots for junctions, labeled I/O pins."
LogicLevelsRepresentation = "Use 1 (HIGH/True) and 0 (LOW/False). Voltage: 5V or 0V only."
BooleanExpressionNotation = "Use + for OR, · or concatenation for AND, ' (prime) or ¬ for NOT."
; Verification
verify_symbols_defined = (✔/) ; (Comment: __)
verify_logic_levels = (✔/)    ; (Comment: __)
verify_notation_consistency = (✔/) ; (Comment: __)
;----------------------------------
; SECTION: Inputs
;----------------------------------
[Possible Inputs]
InputVariables = "A, B"
InputDomain = "Each input ∈ {0,1} (5V or 0V). Or don't-cares in this design."

; Verification
verify_all_inputs_listed = (✔/) ; (Comment: __)
verify_domain_specified = (✔/)  ; (Comment: __)
;----------------------------------
; SECTION: Truth Table
;----------------------------------
[Truth Table]
TruthTableInputs = "A, B"
TruthTableOutputs = "Sum, Carry"
TruthTableFormat = "0/1 for all input and output values."
TruthTableContent = """
+---+---+-----+-------+
| A | B | Sum | Carry |
+---+---+-----+-------+
| 0 | 0 |  0  |   0   |
| 0 | 1 |  1  |   0   |
| 1 | 0 |  1  |   0   |
| 1 | 1 |  0  |   1   |
+---+---+-----+-------+
"""

; Verification
verify_all_combinations = (✔/) ; (Comment: __)
verify_output_values = (✔/)     ; (Comment: __)
verify_table_format = (✔/)      ; (Comment: __)

;----------------------------------
; SECTION: K-Map Reduction
;----------------------------------
[K-Map Reduction]
KMapVariables = "A, B"
KMapLayout = "2x2 with Gray code ordering: 00, 01, 11, 10"
KMapFilling = "Place 1 for (A,B) = (0,1), (1,0), (1,1). Actually (1,1)->Carry, so Sum=0 there"
KMapGrouping = "One group for Sum=1 (covers cells 01 and 10). One single cell or simpler analysis for Carry=1 (cell 11)."
KMapResultExpression = """
Sum  = A'B + AB'
Carry= A·B
"""
; Verification
verify_grouping_complete   = (✔/) ; (Comment: __)
verify_minimal_expression  = (✔/) ; (Comment: __)
verify_expression_correct  = (✔/) ; (Comment: __)

;----------------------------------
; SECTION: Gate Operations
;----------------------------------
[Gate Operations]
Gate1 = "INVERT (A) => A'"
Gate2 = "INVERT (B) => B'"
Gate3 = "AND (A', B) => node1"
Gate4 = "AND (A, B') => node2"
Gate5 = "OR  (node1, node2) => Sum"
Gate6 = "AND (A, B) => Carry"

GateOperationNotes = "Each gate introduces a nominal propagation delay. Ideal logic used for simplicity."

; Verification
verify_gates_complete       = (/❌) ; (Comment: __)
verify_output_consistency   = (/❌) ; (Comment: __)
verify_notation_adherence   = (✔/) ; (Comment: __)
verify_timing_addressed     = (/❌) ; (Comment: __)



;----------------------------------
; SECTION: Circuit Diagram
;----------------------------------
[Circuit Diagram Representation]
DiagramIllustration = Half-Adder Nand Gates with Carry

Carry = A AND B (AND3)

DiagramNotation = "Standard symbols: triangle with circle = NOT, D-shaped = AND, etc."
DiagramLabels = "Inputs: A,B. Outputs: Sum, Carry. Intermediate: A', B', node1, node2."

; Verification
verify_diagram_accuracy    = (✔/) ; (Comment: __)
verify_label_consistency   = (✔/) ; (Comment: __)
verify_symbol_standard     = (✔/) ; (Comment: __)
;----------------------------------
; SECTION: Full Signal Analysis
;----------------------------------
[Full Signal Analysis]
NodeEquations = """
node1 = A' · B
node2 = A  · B'
Sum   = node1 + node2
Carry = A · B
"""
OutputEquation = "Sum, Carry match the K-map expression"
PropagationSteps = "Changes in A,B propagate through NOT->AND->OR for Sum, direct AND for Carry."
TimingAnalysis = "Critical path for Sum is 3 gates (INVERT, AND, OR). Carry is direct AND (1 gate)."
; Verification
verify_node_logic             = (✔/) ; (Comment: __)
verify_propagation_correctness= (/❌) ; (Comment: __)
verify_timing_consistency     = (/❌) ; (Comment: __)
;----------------------------------
; SECTION: SOP Reduction
;----------------------------------
[SOP Reduction]
InitialSOP = "Sum = A'B + AB'; Carry = AB"
ReductionSteps = "Already minimal via K-map or direct observation."
ReducedSOP = "Same as above (A'B + AB') for Sum, AB for Carry."
; Verification
verify_all_min_terms_used = (✔/) ; (Comment: __)
verify_algebraic_steps   = (✔/) ; (Comment: __)
verify_sop_matches_kmap  = (✔/) ; (Comment: __)
;----------------------------------
; SECTION: Boolean Expression Reduction
;----------------------------------
[Boolean Expression Reduction]
InitialExpression     = "Sum = A'B + AB'; Carry = AB"
TargetExpression      = "Sum = A'B + AB'; Carry = AB"
ReductionTechnique    = "Algebraic and K-Map"
ReductionProof        = "Truth table equivalence proven"
FinalBooleanExpression= "Sum = A'B + AB'; Carry = A·B"
; Verification
verify_equivalence_proven = (✔/) ; (Comment: __)
verify_expression_minimal = (✔/) ; (Comment: __)
verify_consistency_final  = (✔/) ; (Comment: __)
;----------------------------------
; SECTION: Direct Links (Cross-Referencing)
;----------------------------------
[Direct Links]
NotationKey_related            = "Used for consistent symbols"
PossibleInputs_related         = "Defines domain for truth table"
TruthTable_related             = "Basis for K-Map + SOP"
KMapReduction_related          = "Produces minimal expression"
GateOperations_related         = "Implements final logic"
CircuitDiagram_related         = "Visual schematic"
FullSignalAnalysis_related     = "Ensures correct signal flow/timing"
SOPReduction_related           = "Confirms minimal SoP matches K-Map"
BooleanExprReduction_related   = "Proves final correctness"
Glossary_related               = "Definitions of logic terms"
;----------------------------------
; SECTION: Glossary
;----------------------------------
[Glossary]
AND_Gate    = "Outputs 1 iff all inputs are 1 (symbol ∧ or ·)"
OR_Gate     = "Outputs 1 if at least one input is 1 (symbol ∨ or +)"
NOT_Gate    = "Outputs inversion of input (symbol ¬, !, or ')"
NAND_Gate   = "Outputs 0 iff all inputs are 1 (symbol ⊼)"
NOR_Gate    = "Outputs 1 iff all inputs are 0 (symbol ↓)"
Logic_1_High= "5V in this lab"
Logic_0_Low = "0V in this lab"
Truth_Table = "Exhaustive listing of input combos vs output"
Karnaugh_Map= "Graphical simplification method for Boolean expressions"
Sum_of_Products= "OR of multiple AND terms"
Boolean_Expression= "Algebraic form with logic operators (AND, OR, NOT)"
Propagation_Delay= "Time from an input change to an observable output change"
Verification_Checklist= "Steps to confirm correctness"
Cross_Referencing= "Linking sections (e.g., from K-Map to SOP)"
Checkmark= "✔ => Passed"
Crossmark= "❌ => Requires correction"
;----------------------------------
; SECTION: Simulation and Results
;----------------------------------
[SIMULATION_AND_RESULTS]
simulation_tool=LTSpice
test_duration=100ns
input_stimulus="""
A: 0->1 at 20ns, 1->0 at 60ns
B: 0->1 at 40ns, 1->0 at 80ns
[WAVEFORM_SETTINGS]
display_configuration="""
Signal Colors:
- A: Blue  (0,0,255)
- B: Red   (255,0,0)
- Sum: Green   (0,255,0)
- Carry: Yellow (255,255,0)
Trace Width: 2px
Background: White
Grid: Light Gray
[SIMULATION_RESULTS]
waveform_analysis="""
Time    | A | B | Sum | Carry | Analysis
0-20ns  | 0 | 0 |  0  |   0   | Initial state
20-40ns | 1 | 0 |  1  |   0   | A transitions high
40-60ns | 1 | 1 |  0  |   1   | B transitions high -> carry=1
60-80ns | 0 | 1 |  1  |   0   | A transitions low
80-100ns| 0 | 0 |  0  |   0   | B transitions low
[VISUALIZATION_TIPS]
waveform_optimization="""
1. Right-click signal name to change colors
2. Use Tools-->Settings-->Waveforms for trace widths
3. Adjust background in Tools-->Color Preferences
4. For digital signals, set threshold=2.5V
[TROUBLESHOOTING_NOTES]
initial_attempts="""
1. Overly complicated design with 4 inputs
2. Mistaken carry input
3. Final solution: 2 inputs (A,B), direct carry as A·B
[DESIGN_ITERATIONS]
version_history="""
v1: Basic design (redundant)
v2: Removed redundancy
v3: Corrected carry logic
v4: Final design with working simulation
v5: Potential future modifications
;----------------------------------
; SECTION: Additional Notation & Implementation
;----------------------------------
[LOGIC_LEVELS_AND_TIMING]
logic_states="""
HIGH=5V, LOW=0V
No intermediate levels allowed
"""
timing_parameters="""
Gate Delays:
 - INVERT=5ns
 - AND/OR/NAND=10ns
Sim. Step=20ns
[SIMULATION_CONSTRAINTS]
voltage_levels="Strict binary 0/5V only"
transition_rules="""
- One input changes at a time
- 20ns interval
- Observe outputs after each transition
[NAND_ONLY_IMPLEMENTATIONS]
NOT_using_NAND="NOT(A) = A NAND A"
AND_using_NAND="(A NAND B) NAND (A NAND B)"
OR_using_NAND="(A NAND A) NAND (B NAND B)"
XOR_using_NAND="((A NAND B) NAND A) NAND ((A NAND B) NAND B)"
;----------------------------------
; SECTION: Design Specifications
;----------------------------------
[DESIGN_SPECIFICATIONS]
block_type=Half_Adder
inputs="A,B"
outputs="Sum,Carry"
constraints="carry_in=fixed_zero"
implementation="Two approaches: Basic (AND/OR/NOT) or NAND-based"
[AVAILABLE_COMPONENTS]
gate_files="LogicLibrary.zip"
logic_gates="""
 - INVERT.asc/asy
 - ANDx.asc/asy
 - ORx.asc/asy
 - NAND.asc/asy
 - NAND3.asc/asy
 - NOR.asc/asy
 - NOR3.asc/asy
 - dff.asc/asy
 - MUX.asc/asy
"""

[IMPLEMENTATION_CONSTRAINT]
xor_replacement="""
XOR not directly available => implement with INVERT/AND/OR
"""
[HALF_ADDER_REVISED]
sum_implementation="Sum = A'B + AB'"
carry_implementation="Carry = A·B"

;----------------------------------
; SECTION: Implementation Approaches
;----------------------------------
[IMPLEMENTATION_APPROACHES]
approach_1_basic="""
Using AND/OR/NOT:
1. Invert A => A'
2. Invert B => B'
3. AND(A',B) => node1
4. AND(A,B') => node2
5. OR(node1,node2) => Sum
6. AND(A,B) => Carry
"""
approach_2_nand="""
Using NAND-based gates:
1. (A,B) => NAND1 -> partial sum
2. (A,B) => NAND2 -> partial sum
3. (NAND1,NAND2) => NAND3 => intermediate
4. (intermediate) => OR => Sum
5. (A,B) => NAND => Carry
"



1. Cover Page
Title: Half Adder & Full Adder Design Documentation Continued 
title: Half_Adder_and_Full_Adder_Design
version: 12.0
assignment: Lab_XX

1. Introduction
Objective To design, implement, and verify both a Half Adder (HA) and a Full Adder (FA).
We will demonstrate:
Their truth tables and Boolean expressions.
Gate-level schematics (with AND/OR/NOT, XOR, or NAND variations).
Simulation results in a tool like LTSpice or Logisim.
Overview
A Half Adder adds two 1-bit inputs (A and B) to produce a 1-bit Sum and a Carry out.
A Full Adder extends this to handle three 1-bit inputs (A, B, and Cin) and produces a 1-bit Sum plus a Carry out.
We will compare logic minimization methods (K-Map, SOP) and show complete verification through simulation.

4. Notation & Symbols

5. Inputs & Truth Tables
### 5.1 Half Adder - Inputs and Truth Table

**Input Variables**
- A, B ∈ {0, 1}

**Output Variables**
- Sum
- Carry

**Truth Table**

| Input A | Input B | Output Sum | Output Carry |
|---------|---------|------------|--------------|
| 0       | 0       | 0          | 0            |
| 0       | 1       | 1          | 0            |
| 1       | 0       | 1          | 0            |
| 1       | 1       | 0          | 1            |

**Boolean Expressions**
- Sum = A ⊕ B  (A XOR B)
- Carry = A · B (A AND B)

**Verification Checklist**
- [ ] verify_input_variables_defined: Input variables A and B are clearly defined and within the binary domain {0, 1}.
- [ ] verify_output_variables_defined: Output variables Sum and Carry are clearly defined.
- [ ] verify_truth_table_accuracy: The truth table accurately represents the behavior of a Half Adder.
- [ ] verify_boolean_expressions_correct: The Boolean expressions for Sum and Carry are correct and consistent with the truth table.
The Sum bit, as shown in the truth table, corresponds to the XOR operation of inputs A and B (A ⊕ B).  This is because the Sum is '1' when either A or B is '1', but not when both are '1'.
The Carry bit is '1' only when both inputs A and B are '1', which directly corresponds to the AND operation (A · B).

### 5.2 Full Adder

A Full Adder extends the functionality of a Half Adder by including a third input, **Carry-in (Cin)**, to accommodate carry bits from previous stages in multi-bit addition.  It also produces two outputs: **Sum** and **Carry-out (Cout)**.

**Input Variables**
- A, B, Cin ∈ {0, 1}

**Output Variables**
- Sum
- Cout

**Truth Table**

| Input A | Input B | Input Cin | Output Sum | Output Cout |
|---------|---------|-----------|------------|-------------|
| 0       | 0       | 0         | 0          | 0           |
| 0       | 0       | 1         | 1          | 0           |
| 0       | 1       | 0         | 1          | 0           |
| 0       | 1       | 1         | 0          | 1           |
| 1       | 0       | 0         | 1          | 0           |
| 1       | 0       | 1         | 0          | 1           |
| 1       | 1       | 0         | 0          | 1           |
| 1       | 1       | 1         | 1          | 1           |

**Boolean Expressions**
- Sum = A ⊕ B ⊕ Cin
- Cout = (A · B) + ((A ⊕ B) · Cin)

These expressions, especially for Cout, will be further simplified using K-Maps in the next section.

## 6. K-Map & SOP Reduction

Karnaugh Maps (K-Maps) provide a visual method to simplify Boolean expressions. We will use K-Maps to derive minimized Sum of Products (SOP) expressions for both the Half Adder and Full Adder circuits.

### 6.1 Half Adder K-Map

**K-Map for Sum:**

```
   B=0  B=1
A=0  0    1
A=1  1    0
```

- **Grouping:**  We identify two groups of '1's, each consisting of a single cell as they are not adjacent to form larger groups.
    - Group 1: Cell (A=0, B=1)  →  Minterm: A'B
    - Group 2: Cell (A=1, B=0)  →  Minterm: AB'

- **SOP Expression for Sum:** Sum = A'B + AB'  which is equivalent to **A ⊕ B**.

**K-Map for Carry:**

```
   B=0  B=1
A=0  0    0
A=1  0    1
```

- **Grouping:**  One group of '1' in cell (A=1, B=1).
    - Group 1: Cell (A=1, B=1)  →  Minterm: AB

- **SOP Expression for Carry:** Carry = **A · B**

These K-Map reductions confirm the Boolean expressions we initially stated for the Half Adder.

```
Single 1 in cell (A=1,B=1) → Carry = A·B
6.2 Full Adder K-Map (For Sum and Cout)

For the Full Adder, we need to consider three inputs (A, B, Cin).  We will use K-Maps to simplify the Boolean expressions for both Sum and Cout.

### 6.2.1 K-Map for Sum (Full Adder)

**Truth Table for Sum (recap):**
| A | B | Cin | Sum |
|---|---|-----|-----|
| 0 | 0 | 0   | 0   |
| 0 | 0 | 1   | 1   |
| 0 | 1 | 0   | 1   |
| 0 | 1 | 1   | 0   |
| 1 | 0 | 0   | 1   |
| 1 | 0 | 1   | 0   |
| 1 | 1 | 0   | 0   |
| 1 | 1 | 1   | 1   |

**K-Map for Sum:**

We'll use a 3-variable K-Map.  One way to represent it is to consider 'Cin' as selecting between two 2x2 K-Maps for 'A' and 'B'.

**Cin = 0**
```
     B=0  B=1
A=0   0    1
A=1   1    0
```

**Cin = 1**
```
     B=0  B=1
A=0   1    0
A=1   0    1
```

**Combined 3-variable K-Map:**

```
       BCin
A=0   00  01  11  10
      0   1   0   1
A=1   1   0   1   0
```

*   **Minterms for Sum:**  m1, m2, m4, m7 (corresponding to Sum=1 in the truth table)

*   **Grouping:** In this K-Map, the 1s are not adjacent in a way that allows for simple rectangular groupings of 2, 4, or 8.  Each '1' essentially forms its own group, or we can group them in pairs diagonally, which leads to XOR patterns.

*   **SOP Expression from K-Map (observing XOR pattern):**  Directly from the truth table or K-Map pattern, we recognize the XOR relationship:

    **Sum = A ⊕ B ⊕ Cin**


### 6.2.2 K-Map for Cout (Full Adder)

**Truth Table for Cout (recap):**
| A | B | Cin | Cout |
|---|---|-----|------|
| 0 | 0 | 0   | 0    |
| 0 | 0 | 1   | 0    |
| 0 | 1 | 0   | 0    |
| 0 | 1 | 1   | 1    |
| 1 | 0 | 0   | 0    |
| 1 | 0 | 1   | 1    |
| 1 | 1 | 0   | 1    |
| 1 | 1 | 1   | 1    |

**K-Map for Cout:**

Using the same 3-variable K-Map structure:

```
       BCin
A=0   00  01  11  10
      0   0   1   0
A=1   0   1   1   1
```

*   **Minterms for Cout:** m3, m5, m6, m7 (corresponding to Cout=1 in the truth table)

*   **Grouping:** We can form the following groups to cover all 1s with the largest possible rectangles:
    1.  A group of two 1s in the bottom row, last two columns (A=1, Cin=1) and (A=1, B=1, Cin=1). This covers minterms m6 and m7 and simplifies to **A·Cin**.
    2.  A group of two 1s in the bottom row, middle two columns (A=1, B=1) and (A=1, B=1, Cin=1). This covers minterms m5 and m7 and simplifies to **A·B**.
    3.  A group of two 1s in the column where B=1 and Cin=1, across both rows (A=0 and A=1). This covers minterms m3 and m7 and simplifies to **B·Cin**.

*   **SOP Expression from K-Map (after grouping):** Combining the prime implicants from the groupings:

    **Cout = (A·B) + (A·Cin) + (B·Cin)**

    Alternatively, and sometimes presented as: **Cout = (A·B) + ((A ⊕ B)·Cin)**.  Both are logically equivalent, but the K-Map grouping directly leads to the first form which is often simpler to implement directly from the K-Map.


**Final Results Summary:**

*   **Sum = A ⊕ B ⊕ Cin**
*   **Cout = (A·B) + (A·Cin) + (B·Cin)**  (or equivalently Cout = (A·B) + ((A ⊕ B)·Cin) )

These Boolean expressions for Sum and Cout of the Full Adder are derived and simplified using the K-Map method.

A=0A=1 B=000 B=101
Single 1 in cell (A=1,B=1) → Carry = A·B
#### 6.2 Full Adder K-Map

For both Sum and Cout in a Full Adder, you can utilize Karnaugh Maps (K-Maps). Given the Full Adder's three inputs (A, B, Cin), a 3-variable K-Map is appropriate. This can be visualized as a 2D K-Map with dimensions like 4 rows × 2 columns or 2 rows × 4 columns. Alternatively, you might opt for two smaller 2-variable K-Maps for a step-by-step simplification if preferred.

##### Final Results

The boolean expressions for the Full Adder, derived from K-Map simplification or direct boolean expansion, are:

*   **Sum = A ⊕ B ⊕ Cin**
*   **Cout = (A ⋅ B) + ((A ⊕ B) ⋅ Cin)**

These expressions are confirmed through both K-Map methods and boolean algebraic manipulation.

```
7. Gate-Level Implementation & Circuit Diagrams
7.1 Half Adder (Basic Gates) {{HalfAdderBasicGates}}
Sum = A'B + AB'
Carry = A·B
Schematic Example (using NOT, AND, OR):

         ┌─►[NOT]─► A'
A -------┤
         │        ┌─►[AND]─┐
         └────────┘         \
B ---------------┐           [OR] ---> SUM
                 └─►[NOT]─► B'      /
                          ┌─►[AND]─┘
                          └─►(A'B, AB')

Carry = A·B (direct AND gate)

#### 7.1.1 Half Adder (NAND Gates) {{HalfAdderNANDGates}}

To implement a Half Adder using only NAND gates, we need to express the Sum and Carry functions using NAND operations.  Recall the boolean expressions:

*   Sum = A'B + AB'
*   Carry = A·B

We can convert these to NAND logic.

**NAND Implementation Steps:**

1.  **Carry (A·B):**  A simple AND gate is equivalent to a NAND gate followed by a NOT (inverter).  However, if we only need the Carry output, and it's used in subsequent NAND logic, we can often leave it as `(A NAND B)'` conceptually, or if the next stage accepts NAND inputs, sometimes `(A NAND B)` itself can be directly used or further manipulated. For a standalone Carry output, we'll use two NANDs to effectively create an AND.

    `Carry = A · B = (A NAND B) NAND (A NAND B)`  (Using a NAND gate as an inverter)

    Alternatively, for simplicity in this context and to align with typical NAND-optimized circuits, we can consider `Carry` directly as `A NAND B` and adjust subsequent logic if needed, or explicitly use a two-NAND AND for clarity if a direct AND is conceptually required. For now, let's aim for direct NAND representation where efficient.  However, for a clear AND function, using two NANDs as inverter is standard. Let's use the two-NAND approach for a clear AND equivalent for 'Carry' for now, and optimize if needed in a more complex circuit.

    `Carry = (A NAND B) NAND (A NAND B)`  (This is logically equivalent to A AND B)

2.  **Sum (A'B + AB'):**  This is the XOR function.  A common NAND implementation for XOR is more involved.  One efficient approach uses four NAND gates:

    *   `A NAND B  =  (AB)'`
    *   ` (A NAND (A NAND B))  =  (A(AB)')' = A' + AB = A' + B`
    *   ` (B NAND (A NAND B))  =  (B(AB)')' = B' + AB = B' + A`
    *   ` ((A NAND (A NAND B)) NAND (B NAND (A NAND B)))  =  ((A'+B) NAND (B'+A)) = ((A'+B)(B'+A))' = (A'B' + A'A + BB' + BA)' = (A'B' + AB)' = (A'B')' (AB)' = (A+B)(A'+B') = AA' + AB' + BA' + BB' = AB' + A'B = A XOR B`

    Thus,  `Sum = ((A NAND (A NAND B)) NAND (B NAND (A NAND B)))`
**Schematic Example (using NAND gates):**

```
         ┌─►[NAND3]─┐
     A --┤          ├──►[NAND4]──────┐
         └──────────┘                 \
                                       [NAND5] ---> SUM
     B -----------------┐             /
                       └─►[NAND3]─┘


Carry (Implemented as AND using NAND gates):

     A --►[NAND1]─┐
         └────────┤
                   ├──►[NAND2] ---> CARRY
     B --►[NAND1]─┘
```


**Simplified Schematic (NAND gates - Sum and Carry combined):**

```
         ┌─►[NAND1]─┐
     A --┤          ├──►[NAND4]──────┐
         └──────────┘                 \
                                       [NAND5] ---> SUM
     B -----------------┐             /
                       └─►[NAND2]─┐
                       └──────────┤
                                 ├──►[NAND3]─► CARRY
                                 └──────────┘

(NAND1: A NAND B,  NAND2: A NAND NAND1,  NAND3: B NAND NAND1,  NAND4: NAND2 NAND NAND3, NAND5: NAND1 NAND NAND1)

Note: NAND5 for Carry is to explicitly create an AND function from NAND if needed as a direct AND output. In many contexts, NAND1 output itself might be usable as 'Carry' depending on subsequent logic. For clarity, NAND5 is shown to represent a clear AND function for Carry.

7.2 Full Adder (Ripple version) {{FullAdderRipple}}
Basic approach:
Half Adder 1: S1 = A ⊕ B, C1 = A·B
Half Adder 2: Final Sum = S1 ⊕ Cin, C2 = S1·Cin
Cout = C1 + C2
Schematic Example (using two half adders as built + OR gate for carry):

      ┌───[HA1]─────► S1
A,B --│             \
      └───> C1       \
Cin ------[HA2]------(XOR)----> FINAL SUM
           └──> C2

Cout = C1 + C2  (OR)


#### 7.2.1 Full Adder (NAND Gates Implementation) {{FullAdderNAND}}

We can implement a Full Adder using NAND gates by replacing the Half Adders in the ripple carry structure with their NAND gate equivalents, and also implementing the final OR gate for Cout using NAND gates.

**NAND Gate Implementation of a Half Adder**

To implement a Half Adder using only NAND gates, we can directly construct the Sum (A ⊕ B) and Carry (A · B) outputs using NAND logic.  Let's break down the implementation:

**Sum (A ⊕ B) Implementation using NAND gates:**

The XOR function (A ⊕ B) can be expressed and implemented using NAND gates in a few steps.  One efficient approach uses four NAND gates:

1.  **NAND1:**  Compute `NAND1 = A NAND B`. This serves as a partial term in both Sum and Carry logic.
2.  **NAND2:**  Compute `NAND2 = A NAND NAND1`.  This is equivalent to `A NAND (A NAND B)`.
3.  **NAND3:**  Compute `NAND3 = B NAND NAND1`.  This is equivalent to `B NAND (A NAND B)`.
4.  **NAND4:**  Compute `Sum = NAND2 NAND NAND3`. This final NAND gate combines the outputs of NAND2 and NAND3 to produce the XOR result, `Sum = A ⊕ B`.

**Carry (A · B) Implementation using NAND gates:**

The Carry function (A · B) is simpler to implement with NAND gates.  We know that AND can be obtained from NAND by inverting the output of a NAND gate.  And an inverter can be made from a NAND gate by connecting its inputs together.

1.  **NAND5 (or reuse NAND1):** Compute `Carry = NAND1 NAND NAND1`. Since `NAND1 = A NAND B`, then `Carry = (A NAND B) NAND (A NAND B)`.  This is equivalent to inverting the output of `NAND1`, which effectively gives us `Carry = (A NAND B)' = A · B`.  Alternatively, we can simply reuse the output of `NAND1` and feed it into a NAND gate with itself as both inputs.  If we are optimizing gate count, we can reuse `NAND1` calculated for the Sum logic.

**Simplified Schematic (NAND gates - Sum and Carry for Half Adder):**

```
         ┌─►[NAND1]─┐
     A --┤          ├──►[NAND4]──────► SUM (A ⊕ B)
         │          │
         └──────────┘
         │
         └─►[NAND2]──┐
                      │
     B -------------┤
         └─►[NAND3]──┘


Carry: [NAND1]──►[NAND5]──────► CARRY (A · B)
       (output of NAND1)
```

In this schematic:
- NAND1 = A NAND B
- NAND2 = A NAND (A NAND B)
- NAND3 = B NAND (A NAND B)
- NAND4 = NAND2 NAND NAND3 = Sum (A ⊕ B)
- NAND5 = NAND1 NAND NAND1 = Carry (A · B)

**Note:**  This implementation shows how a Half Adder can be constructed entirely using NAND gates.  While there might be other arrangements, this approach clearly demonstrates the principle of building both the Sum and Carry outputs using a combination of NAND gates, effectively utilizing NAND gates as inverters and basic logic elements to achieve the desired Half Adder functionality.

The "TODO SHOW NAND GATE IMPLIMENTATION" is now addressed by providing NAND gate implementations for both Half Adder and a ripple carry Full Adder using NAND-based Half Adders.

```
8. Full Signal & Timing Analysis
Node Equations
For the Half Adder: node1 = A'·B, node2 = A·B', Sum = node1 + node2, Carry = A·B.
For the Full Adder: combine the partial sums/carries as shown above.
Propagation Delays
Each NOT or AND/OR gate has some nominal delay (e.g., 5–10 ns).
The critical path for the Half Adder's Sum might be (NOT → AND → OR) ~ 25 ns total.
For the Full Adder, you may have two half-adder delays in series plus an OR gate for the final carry.
Timing Diagram
If A and B change simultaneously, observe Sum and Carry after the gate delays.
No "memory" behavior here, so after inputs settle, outputs quickly reflect the new sum/carry.

9. LTSpice Simulation & Netlists
9.1 Simulation Setup
Tool: LTSpice (or Logisim, Multisim, etc.)
Transient Analysis: 0 to 80 ns, step 1 ns (for example).
Input Stimulus: Switch A and B at 20 ns intervals to cycle through all 4 input combos (0,0 → 0,1 → 1,0 → 1,1).
Example Input Stimulus
A: 0 → 1 at 20 ns, 1 → 0 at 60 ns
B: 0 → 1 at 40 ns, 1 → 0 at 80 ns
9.2 Example Netlist (Half Adder with basic gates)
ruby
Copy code
* HALF ADDER Netlist
* (Uses NOT, AND, OR from your library)
.include LogicLibSymbols.inc

VIN_A A 0 PWL(0ns 0V 20ns 0V 20.1ns 5V 60ns 5V 60.1ns 0V 80ns 0V)
VIN_B B 0 PWL(0ns 0V 40ns 0V 40.1ns 5V 80ns 5V)

XU1 A vdd 0 A_INV INVERT
XU2 B vdd 0 B_INV INVERT
XU3 A_INV B vdd 0 N1 ANDx      ; node for A'·B
XU4 A B_INV vdd 0 N2 ANDx      ; node for A·B'
XU5 N1 N2 vdd 0 SUM ORx        ; Sum = (A'·B) + (A·B')
XU6 A B vdd 0 CARRY ANDx       ; Carry = A·B

Vdd vdd 0 5V
.tran 0 80n
.end
(Adapt gate names, netlist lines, or library includes for your environment.)
9.3 Waveform Analysis






[TIMING_COMPARISON]
basic_implementation="Sum path=25ns, Carry=10ns, 5 total gates"
nand_implementation="Sum path=30ns, Carry=10ns, 4 total gates"

;----------------------------------
; SECTION: LTSpice Netlists
;----------------------------------
[LTSPICE_SIMULATION_BOTH]
basic_netlist="""
* HALF ADDER: Basic (INVERT, AND, OR)
XU1 A vdd 0 N001 INVERT
XU2 B vdd 0 N002 INVERT
XU3 N001 B vdd 0 N003 ANDx
XU4 A N002 vdd 0 N004 ANDx
XU5 N003 N004 vdd 0 Sum ORx
XU6 A B vdd 0 Carry ANDx
"""

nand_netlist="""
* HALF ADDER: NAND-based
XU1 A B vdd 0 N001 NAND
XU2 A B vdd 0 N002 NAND
XU3 N001 N002 vdd 0 N003 NAND
XU4 N003 vdd 0 Sum ORx
XU5 A B vdd 0 Carry NAND
"""

[IMPLEMENTATION_CHOICE_FACTORS]
considerations="""
1. Gate availability
2. Timing constraints
3. Area vs. reliability
4. Fewer gates vs. simpler debug
"""

[VERIFICATION_FOR_BOTH]
test_points="""
1. Verify inverters
2. Verify AND operations
3. Check final OR or NAND chain
4. Confirm correct Sum/Carry for all combos
"""

;----------------------------------
; SECTION: Results & Analysis
;----------------------------------
[RESULTS_AND_ANALYSIS]
timing_analysis="""
0-20ns: A=0,B=0 => Sum=0,Carry=0
20-40ns: A=1,B=0 => Sum=1,Carry=0
40-60ns: A=1,B=1 => Sum=0,Carry=1
60-80ns: A=0,B=1 => Sum=1,Carry=0
80-100ns:A=0,B=0 => Sum=0,Carry=0
No glitches, final stable outputs as expected.
"""

[DESIGN_HISTORY]
iterations="""
v1: Redundant approach
v2: Simplified signals
v3: Carry fix
v4: Final validated
"""

;----------------------------------
; SECTION: Visualization Guidelines
;----------------------------------
[VISUALIZATION_GUIDELINES]
setup_steps="""
1. Color each waveform distinctly
2. Use digital plotting or threshold=2.5V
3. Capture screenshots at stable intervals
"""

;----------------------------------
; SECTION: Verification Checklist
;----------------------------------
[VERIFICATION_CHECKLIST]
verifications="""
1. truth_table_verified
2. timing_requirements_met
3. carry_generation_correct
4. waveform_visualization_optimized
"""

;----------------------------------
; SECTION: Gate-Level Implementation (Detailed)
;----------------------------------
[GATE_LEVEL_IMPLEMENTATION]
half_adder_using_available="""
A' = INVERT(A)
B' = INVERT(B)
node1 = AND(A', B)
node2 = AND(A, B')
Sum   = OR(node1, node2)
Carry = AND(A,B)
"""

;----------------------------------
; SECTION: Timing Analysis (Specific)
;----------------------------------
[TIMING_ANALYSIS_SPECIFIC]
gate_delays="""
INVERT=5ns, AND=10ns, OR=10ns
Longest path => 25ns for Sum
Carry => 10ns
"""

[COMPONENT_CONSTRAINTS]
voltage_levels="5V or 0V only"
fan_out_limits="Max 4 loads/gate"
timing_constraints="Min 20ns pulse, 10ns setup/hold"

[LTSPICE_SIMULATION_SETUP]
simulation_commands="""
.tran 0 100n 0 0.1n
VA A 0 PWL(0 0 20n 0 20.1n 5 60n 5 60.1n 0)
VB B 0 PWL(0 0 40n 0 40.1n 5 80n 5 80.1n 0)
Vdd vdd 0 5
"""

waveform_setup="""
Plot digital signals
Threshold=2.5V
Measure rise/fall and propagation delay
"""

netlist_example="""
Same as 'basic_netlist' or 'nand_netlist' depending on approach
"""

[VERIFICATION_POINTS]
signal_checks="""
Check transitions at 20ns intervals
Confirm final outputs stable after ~10ns
Ensure no hazards
"""

;----------------------------------
; SECTION: Optimization Techniques
;----------------------------------
[OPTIMIZATION_TECHNIQUES_UNRELATED]
shared_gate_optimization="Gate sharing to reduce count"
critical_path_optimization="Rearrange gates to reduce series depth"
fan_out_optimization="Use buffers to avoid large fan-out"
power_optimization="Reduce switching, gate sizing"
timing_optimization="Balance path delays, cluster gates"

[OPTIMIZATION_VERIFICATION]
checklist="""
- Gate count improvements
- Reduced path delay
- Respect fan-out <=4
- Acceptable power
- No timing violations
"""

[OPTIMIZATION_METRICS]
performance_measures="""
1. Gate Count
2. Delay
3. Fan-out
4. Area
"""

outline for your Half Adder Lab Report, covering:
	•	Notation & Glossary
	•	Inputs & Truth Table
	•	K-Map & SOP Reductions
	•	Final Gate Implementation & Circuit Diagram
	•	Full Signal & Timing Analysis
	•	LTSpice Simulation & Netlists
	•	Verification Checklists
	•	Optional Optimization Techniques

;=============================================================
; Lab Report: Half Adder and Full Adder Implementations
;==============================================================
[DOCUMENT_METADATA]
title=Adder_Design_Documentation
version=8.0
date=2024-02-XX
author=Ryan_Oates
course==Lab_Two _half_adder_full_adder
professor=Smilkstein
implementation=LTSpice
;--------------------------------------------------------------
	1.	Definitions and Glossary
	2.	Notation & Symbols
	3.	Half Adder (both basic and NAND-based approaches)
	4.	Full Adder (basic Boolean approach and an alternative NAND-based approach)
	5.	Simulation Setup & Netlists
	6.	Verification & Troubleshooting
;-------------------------------------------------------------
; 1. DEFINITIONS AND GLOSSARY
;--------------------------------------------------------------
[NOTATION_AND_SYMBOLS]
GateSymbolNotation="
- AND = •
- OR = +
- NOT = ¬ or '
- NAND = ⊼
- NOR = ↓
- XOR = ⊕
"
WireConnectionSymbols="Lines (─), junction dots, labeled I/O pins"
LogicLevelsRepresentation="
HIGH=1 (5V)
LOW=0 (0V)
Strict binary (no intermediate voltages)
"
BooleanExpressionNotation="
- Use + for OR
- Use · or concatenation for AND
- Use ¬(A) or A' for NOT
- Use ⊕ for XOR (if available)
"
Glossary="
AND Gate: Outputs 1 iff all inputs=1
OR Gate: Outputs 1 if ≥ one input=1
NOT Gate: Inversion of single input
NAND Gate: NOT of AND
NOR Gate: NOT of OR
XOR Gate: Outputs 1 if inputs differ
HA: Half Adder
FA: Full Adder
Propagation Delay: Time from input change to output change
"

;--------------------------------------------------------------
; 2. AVAILABLE COMPONENTS AND CONSTRAINTS
;--------------------------------------------------------------
[AVAILABLE_COMPONENTS]
lab_components="
1. INVERT.asc/asy (NOT gate)
2. ANDx.asc/asy (AND gate)
3. ORx.asc/asy (OR gate)
4. NAND.asc/asy (2-input NAND)
5. NAND3.asc/asy (3-input NAND)
6. NOR.asc/asy (2-input NOR)
7. NOR3.asc/asy (3-input NOR)
8. dff.asc/asy (D Flip-Flop)
9. MUX.asc/asy (Multiplexer)
"

[DESIGN_CONSTRAINTS]
voltage_levels="
HIGH=5V only
LOW=0V only
No intermediate voltages allowed
"
timing_requirements="
Gate Delays (typical):
- INVERT: 5ns
- AND/OR: 10ns
- NAND/NOR: 10ns

Setup/Hold:
- Min pulse width: 20ns
- Setup time: 10ns
- Hold time: 10ns
"

;--------------------------------------------------------------
; 3. HALF ADDER IMPLEMENTATIONS
;--------------------------------------------------------------
[HALF_ADDER_OVERVIEW]
description="
A Half Adder (HA) takes two 1-bit inputs (A, B) and produces:
 - Sum (LSB)
 - Carry (MSB)
"
truth_table="
+---+---+-----+-------+
| A | B | Sum | Carry |
+---+---+-----+-------+
| 0 | 0 |  0  |   0   |
| 0 | 1 |  1  |   0   |
| 1 | 0 |  1  |   0   |
| 1 | 1 |  0  |   1   |
+---+---+-----+-------+
"

[HALF_ADDER_BASIC]
comment="Using NOT, AND, OR gates"
logic_expression="
Sum   = A'B + AB'
Carry = A·B
"
circuit_diagram="
 A ─┬─► [NOT1] ─► [AND1] ─┐
   │                       ├─► [OR] ─► SUM
   ├──────────► [AND2] ───┘
   │
 B ─┼─► [NOT2] ─┘
   │
   └────────────► [AND3] ─► CARRY
"
netlist="
* Half Adder - Basic Implementation
XU1 A vdd 0 N001 INVERT      ; A'
XU2 B vdd 0 N002 INVERT      ; B'
XU3 N001 B vdd 0 N003 ANDx   ; A'B
XU4 A N002 vdd 0 N004 ANDx   ; AB'
XU5 N003 N004 vdd 0 SUM ORx  ; Sum
XU6 A B vdd 0 CARRY ANDx     ; Carry
"

[HALF_ADDER_NAND]
comment="Using NAND gates and an AND for Carry"
logic_expression="
Sum via NAND-based logic
Carry via AND(A,B)
"
circuit_diagram="
         ┌─► [NAND1] ─┐
 A ─┬───►┤            ├─► [NAND3] ─► [OR] ─► SUM
    │    └─► [NAND2] ─┘
    │
    └────────► [AND] ───────────────► CARRY
       (A·B)
"
netlist="
* Half Adder - NAND-based Implementation
XU1 A B vdd 0 N001 NAND
XU2 A B vdd 0 N002 NAND
XU3 N001 N002 vdd 0 N003 NAND
XU4 N003 vdd 0 SUM ORx
XU5 A B vdd 0 CARRY ANDx
"

[HALF_ADDER_TIMING]
basic_ha_timing="
Sum path: NOT->AND->OR => ~25ns
Carry path: AND => ~10ns
"
nand_ha_timing="
Sum path: NAND->NAND->OR => ~30ns
Carry path: AND => ~10ns
"
comments="
Basic design is simpler to troubleshoot but uses more gates.
NAND design has fewer gates overall but the Sum path is slightly slower.
"

;--------------------------------------------------------------
; 4. FULL ADDER IMPLEMENTATIONS
;--------------------------------------------------------------
[FULL_ADDER_OVERVIEW]
description="
A Full Adder (FA) adds three 1-bit inputs:
 - A, B (operands), and Cin (carry-in)
Produces two outputs:
 - Sum (LSB)
 - Cout (carry-out)
"
truth_table="
+---+---+-----+-------+-------+
| A | B | Cin | Sum   | Cout  |
+---+---+-----+-------+-------+
| 0 | 0 |  0  |   0   |   0   |
| 0 | 0 |  1  |   1   |   0   |
| 0 | 1 |  0  |   1   |   0   |
| 0 | 1 |  1  |   0   |   1   |
| 1 | 0 |  0  |   1   |   0   |
| 1 | 0 |  1  |   0   |   1   |
| 1 | 1 |  0  |   0   |   1   |
| 1 | 1 |  1  |   1   |   1   |
+---+---+-----+-------+-------+
"

[FULL_ADDER_BASIC]
comment="Using two Half Adders + OR gate"
logic_expression="
Sum  = A ⊕ B ⊕ Cin
Cout = (A·B) + ((A ⊕ B)·Cin)
"
circuit_diagram="
           ┌───[HA1]───┐
     A ----┤          ├──► S1 ----┐
           │          │           │   ┌───[HA2]───┐
     B ----┤          │           ├───┤          ├──► Sum
           └───> C1 ──┘           │   └───> C2 ──┘
                                   │
     Cin --------------------------┘

     C1 --------------------------┐
                                   ├─► [OR] ──► Cout
     C2 --------------------------┘
"
netlist="


[FULL_ADDER_NAND]
comment="Full Adder using Universal NAND gates"
logic_expression="
Sum  = A ⊕ B ⊕ Cin  (implemented with NAND gates)
Cout = (A·B) + ((A ⊕ B)·Cin) (implemented with NAND gates)
"
circuit_diagram="
(NAND Gate Implementation)

     A ------------------► NAND1 ---┐
                                    │
     B ------------------► NAND1 ---┤-------► NAND4 ---------┐
                                    │                        │
                                    └───────────────► NAND4 ---------► SUM
                                                             │
     A ----------► NAND2 ---┐                             │
                             │                             │
     NAND1_out ---► NAND2 ---┤-------► NAND5 -------------┘
                             │
     B ----------► NAND3 ---┐
                             │
     NAND1_out ---► NAND3 ---┘


     Cin ----------------------------------------------------► NAND6 ---┐
                                                                       │
     NAND4_out (Sum of HA1) --------------------------------► NAND6 ---┤-------► NAND8 ---------┐
                                                                       │                        │
     NAND5_out (Carry of HA1) ------------------------------► NAND7 ---┤                       │
                                                                       │                        │
     Cin ----------------------------------------------------► NAND7 ---┤-------► NAND8 ---------► Cout
                                                                       │
     NAND5_out (Carry of HA1) ------------------------------------------┘


(Conceptual Block Diagram using NAND-based Half Adders and OR)

      ┌───────────────┐     ┌───────────────┐
A, B --┤ NAND HA #1    ├──► S1 ------------┤ NAND HA #2    ├──► Sum
      └───────────────┘     └───────────────┘
           └──► C1 ──────────────┘
                                   ┌───────────────┐
     Cin --------------------------┤ NAND HA #2    ├──► S2 (Sum)
                                   └───────────────┘
                                        └──► C2 ───────────┐
                                                            │
     C1 ----------------------------------------------------┤ NAND-OR ├──► Cout
                                                            │
     C2 ----------------------------------------------------┤ NAND-OR ──┘

     (NAND-OR can be implemented with 3 NAND gates)
"
netlist="
* Full Adder - NAND-based Implementation (conceptual)
* Each logic function (XOR, AND, OR) is realized solely with NAND gates
XU1 A B vdd 0 NAND_XOR1      ; Stage 1: Compute partial XOR (A ⊕ B) using NAND network
XU2 NAND_XOR1_out Cin vdd 0 NAND_XOR2  ; Stage 2: Final Sum = (A ⊕ B) ⊕ Cin using NAND network
XU3 A B vdd 0 NAND_AND1      ; Stage 3: Generate partial carry1 (A AND B via NAND inversion)
XU4 NAND_XOR1_out Cin vdd 0 NAND_AND2  ; Stage 4: Generate partial carry2 [(A ⊕ B) AND Cin via NAND inversion]
XU5 NAND_AND1_out NAND_AND2_out vdd 0 NAND_OR1  ; Stage 5: Combine partial carries with a NAND-based OR to yield Cout
"

;-------------------------------------------------------------[VERIFICATION_CHECKLIST]
functional_check="
1. Truth Table Match?
2. Timing within 100ns window?
3. No spurious glitches in waveform
4. Outputs stable at 5V or 0V only?
"
timing_check="
1. Propagation delay < 40ns or 50ns (design dependent)
2. Rise/Fall times < 10ns
3. No overlap or race conditions
"
fanout_check="
1. Max fan-out = 4
2. Additional buffer if exceeded
"
comments="
Mark each check ✔ or ❌ with explanations
"

[TROUBLESHOOTING_GUIDE]
common_issues="
1. Output not at full 5V => Possibly excessive load
2. Glitches => Gate mismatch or timing violation
3. Wrong sum/carry => Double-check gate connections
"
debug_steps="
1. Verify each gate in isolation
2. Check node voltages in DC op point
3. Re-check netlist against logic diagram
4. Use .meas to track timing and power
"

;--------------------------------------------------------------
area_optimization="
1. Fewer gates => smaller area
2. NAND-only approach can reduce gate count
L

[PERFORMANCE_METRICS]
gate_count="
- Half Adder Basic: ~6 gates
- Half Adder NAND-based: ~4 gates
- Full Adder Basic: ~2x half adder + extra OR
- Full Adder NAND-based: gates vary but often fewer net
"

;--------------------------------------------------------------
; 8. DOCUMENTATION FRAMEWORK
;--------------------------------------------------------------
[REPORT_STRUCTURE]
outline="
1. Introduction
2. Half Adder
3. Full Adder
4. Simulation Setup
(PENDING)

5. Results & Waveforms
6. Verification & Troubleshooting
7. Optimization
8. Conclusion
9. Appendix
"

[VERSION_CONTROL]
design_evolution="
v1.0: Basic HA + FA
v1.1: NAND-based alternatives with AND Carryv
1.2: Verified simulation, final version
"

[CONCLUSION]
summary="

- Verified correct outputs via truth tables




[XOR_OPERATION_DEFINITION]
symbol=⊕
binary_addition="
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 0 (carry=1)
"
xor_truth_table="
A⊕B=Sum bit of binary addition (no carry)
0⊕0=0
0⊕1=1
1⊕0=1
1⊕1=0
"
implementation="
A⊕B=(A'B+AB')
"

[LOGIC_LEVELS_AND_TIMING]
logic_states="
HIGH(1/True)=5V
LOW(0/False)=0V
Rise/Fall time~10ns typical for each gate
"
timing_parameters="
Gate Delay (Tpd):
  - NAND=10ns
  - NOT=5ns
Total path delay=summed over gates in critical path
Simulation:
  - Time step=20ns
  - Total=100ns
"

[SIMULATION_CONSTRAINTS]
voltage_levels="Binary only: 5V or 0V"
transition_rules="
1. Inputs change in 20ns intervals
2. One input changes at a time
3. 20ns settling after each change
4. Output measured after settling
"

[NAND_ONLY_IMPLEMENTATIONS]
NOT_using_NAND="
NOT(A)=A NAND A
"
AND_using_NAND="
AND(A,B)=(A NAND B) NAND (A NAND B)
"
OR_using_NAND="
OR(A,B)=(A NAND A) NAND (B NAND B)
"
XOR_using_NAND="
XOR(A,B)=((A NAND B) NAND A) NAND ((A NAND B) NAND B)
"

[NAND_IMPLEMENTATION_NOTES]
gate_count="
NOT:1 NAND
AND:2 NANDs
OR:3 NANDs
XOR:4 NANDs
"
critical_paths="
NOT=1 gate delay
AND=2 gates
OR=2 gates
XOR=3 gates
"
optimization_notes="
1. XOR can be optimized in some use cases
2. Intermediate outputs can be shared
3. Must respect fan-out limitations
4. Gate delays add up in cascades
"

[VERIFICATION_STEPS]
nand_implementation_check="
1. Match each NAND-based gate's truth table
2. Check fan-out limits
3. Measure path delays
4. Confirm no timing hazards
"

[DESIGN_SPECIFICATIONS]
block_type="Half_Adder_with_NAND"
inputs="A,B"
outputs="Sum,Carry"
constraints="carry_in=fixed_zero"
implementation="NAND_Based" or "AND Based"

[AVAILABLE_COMPONENTS]
gate_files="LogicLibrary.zip"
LogicGates="
- INVERT.asc/asy (NOT)
- ANDx.asc/asy (AND)
- ORx.asc/asy (OR)
- NAND.asc/asy (2-input NAND)
- NAND3.asc/asy (3-input NAND)
- NOR.asc/asy (2-input NOR)
- NOR3.asc/asy (3-input NOR)
- dff.asc/asy (D Flip-Flop)
- MUX.asc/asy (Multiplexer)
"

[IMPLEMENTATION_CONSTRAINT]
xor_replacement="
XOR must be built from available gates since XOR gate is not  directly provided:
A⊕B=(A'B)+(AB')
"

[HALF_ADDER]
sum_implementation="
Sum=A'B+AB'
Steps:
1. Invert A->A'
2. Invert B->B'
3. AND(A',B)->term1
4. AND(A,B')->term2
5. OR(term1,term2)->Sum
"
carry_implementation="
Carry=A·B
"

[IMPLEMENTATION_APPROACHES]
approach_1_basic="
(AND/OR/NOT approach)
A→[INVERT1]->A'
B→[INVERT2]->B'
AND1=(A'•B)
AND2=(A•B')
OR1=(AND1+AND2)=Sum
AND3=(A•B)=Carry
"
approach_2_nand="
Use NAND gates primarily.
Fewer total gates, though possibly extra intermediate stages.
"

[TIMING_COMPARISON]
basic_implementation="
Sum path=INVERT(5ns)+AND(10ns)+OR(10ns)=25ns
Carry path=AND(10ns)
"
nand_implementation="
Sum path may have more NAND stages (~30ns)
Carry path=1 NAND(10ns)
"

[LTSPICE_SIMULATION_BOTH]
basic_netlist="
* Half Adder (AND/OR/NOT)
XU1 A vdd 0 N001 INVERT
XU2 B vdd 0 N002 INVERT
XU3 N001 B vdd 0 N003 ANDx
XU4 A N002 vdd 0 N004 ANDx
XU5 N003 N004 vdd 0 Sum ORx
XU6 A B vdd 0 Carry ANDx
"
nand_netlist="
* Half Adder (NAND)
XU1 A B vdd 0 N001 NAND
XU2 A B vdd 0 N002 NAND
XU3 N001 N002 vdd 0 N003 NAND
XU4 N003 vdd 0 Sum ORx
XU5 A B vdd 0 Carry NAND
"

[IMPLEMENTATION_CHOICE_FACTORS]
considerations="
1. Gate availability

"

[VERIFICATION_FOR_BOTH]
truth_table="
 A | B | Sum | Carry
---+---+-----+------
 0 | 0 |  0  |   0
 0 | 1 |  1  |   0
 1 | 0 |  1  |   0
 1 | 1 |  0  |   1
"
test_points="
1. Check INVERT outputs or NAND outputs
2. Verify AND/OR or NAND cascades
3. Confirm Sum/Carry match truth table
"

[SIMULATION_SETUP]
tool="LTSPICE"
duration="100ns"
input_stimulus="
A: 0->1 at 20ns, 1->0 at 60ns
B: 0->1 at 40ns, 1->0 at 80ns
"

; SECTION: SOP Reduction
;----------------------------------
[SOP Reduction]
InitialSOP = "Sum = A'B + AB'; Carry = AB"
ReductionSteps = "Already minimal via K-map or direct observation."
ReducedSOP = "Sum = A'B + AB'; Carry = AB"

; Verification
verify_all_minterms_used = (✔/❌) ; (Comment: __)
verify_algebraic_steps   = (✔/❌) ; (Comment: __)
verify_sop_matches_kmap  = (✔/❌) ; (Comment: __)

;----------------------------------
; SECTION: Boolean Expression Reduction
;----------------------------------
[Boolean Expression Reduction]
InitialExpression     = "Sum = A'B + AB'; Carry = AB"
TargetExpression      = "Sum = A'B + AB'; Carry = AB"
ReductionTechnique    = "Algebraic and K-Map"
ReductionProof        = "Truth table equivalence proven"
FinalBooleanExpression= "Sum = A'B + AB'; Carry = A·B"

; Verification
verify_equivalence_proven = (✔/❌) ; (Comment: __)
verify_expression_minimal = (✔/❌) ; (Comment: __)
verify_consistency_final  = (✔/❌) ; (Comment: __)

;----------------------------------
; SECTION: Direct Links (Cross-Referencing)
;----------------------------------
[Direct Links]
NotationKey_related            = "Used for consistent symbols"
PossibleInputs_related         = "Defines domain for truth table"
TruthTable_related             = "Basis for K-Map + SOP"
KMapReduction_related          = "Produces minimal expression"
GateOperations_related         = "Implements final logic"
CircuitDiagram_related         = "Visual schematic"
FullSignalAnalysis_related     = "Ensures correct signal flow/timing"
SOPReduction_related           = "Confirms minimal SoP matches K-Map"
BooleanExprReduction_related   = "Proves final correctness"
Glossary_related               = "Definitions of logic terms"

;----------------------------------
; SECTION: Glossary
;----------------------------------
[Glossary]
AND_Gate    = "Outputs 1 iff all inputs are 1 (symbol ∧ or ·)"
OR_Gate     = "Outputs 1 if at least one input is 1 (symbol ∨ or +)"
NOT_Gate    = "Outputs inversion of input (symbol ¬, !, or ')"
NAND_Gate   = "Outputs 0 iff all inputs are 1 (symbol ⊼)"
NOR_Gate    = "Outputs 1 iff all inputs are 0 (symbol ↓)"
XOR_Gate    = "Outputs 1 iff inputs differ (symbol ⊕)"
Logic_1_High= "5V in this lab"
Logic_0_Low = "0V in this lab"
Truth_Table = "Exhaustive listing of input combos vs output"
Karnaugh_Map= "Graphical simplification method for Boolean expressions"
Sum_of_Products= "OR of multiple AND terms"
Boolean_Expression= "Algebraic form with logic operators (AND, OR, NOT, etc.)"
Propagation_Delay= "Time from input change to an observable output change"
Verification_Checklist= "Steps to confirm correctness"
Cross_Referencing= "Linking sections (e.g., from K-Map to SOP)"
Checkmark= "✔ => Passed"
Crossmark= "❌ => Requires correction"

;----------------------------------
; SECTION: Simulation and Results
;----------------------------------
[SIMULATION_AND_RESULTS]
simulation_tool=LTSpice
test_duration=100ns
input_stimulus="""
A: 0->1 at 20ns, 1->0 at 60ns
B: 0->1 at 40ns, 1->0 at 80ns
"""

[WAVEFORM_SETTINGS]
display_configuration="""
Signal Colors:
- A: Blue  (0,0,255)
- B: Red   (255,0,0)
- Sum: Green   (0,255,0)
- Carry: Yellow (255,255,0)
Trace Width: 2px
Background: White
Grid: Light Gray
"""

[SIMULATION_RESULTS]

[RESULTS_AND_ANALYSIS]
timing_analysis="
Time    | A | B | Sum | Carry
0-20ns  | 0 | 0 |  0  |   0
20-40ns | 1 | 0 |  1  |   0
40-60ns | 1 | 1 |  0  |   1
60-80ns | 0 | 1 |  1  |   0
80-100ns| 0 | 0 |  0  |   0
"
Ok
[DESIGN_HISTORY]
iterations="
v1: Redundant design
v2: Simplified inputs
v3: Correct carry logic
v4: Final verified version
"

[VISUALIZATION_GUIDELINES]
setup_steps="
1. Right-click signal names to change colors
2. Tools→Settings→Waveforms to adjust trace widths
3. Tools→Color Preferences→Waveform to set background
4. Use high contrast colors
"

[GATE_LEVEL_IMPLEMENTATION]
half_adder_using_available="
Sum=(A'B+AB')
Carry=(A·B)

Circuit:
 A---[INVERT1]--->A'
 B---[INVERT2]--->B'

 AND1: (A'•B)
 AND2: (A•B')
 OR1:  (AND1+AND2)=Sum
 AND3: (A•B)=Carry
"

[TIMING_ANALYSIS_SPECIFIC]
gate_delays="
INVERT=5ns
AND=10ns
OR=10ns
Total sum path=25ns
Carry path=10ns
"

[COMPONENT_CONSTRAINTS]
voltage_levels="
HIGH=5V
LOW=0V
No intermediate voltages
"
fan_out_limits="
Max fan-out=4
Use buffers if exceeded
"
timing_constraints="
Min pulse width=20ns
Setup=10ns
Hold=10ns
"

[LTSPICE_SIMULATION_SETUP]
simulation_commands="
.tran 0 100n 0 0.1n
Vdd vdd 0 5
VA A 0 PWL(...)
VB B 0 PWL(...)
"

[VERIFICATION_POINTS]
signal_checks="
1. Verify input transitions
2. Validate output after each gate delay
3. Check for glitches
"

[OPTIMIZATION_TECHNIQUES]
shared_gate_optimization="
Use common NAND outputs for multiple XOR gates, respecting fan-out
"
critical_path_optimization="
Rearrange gates to reduce max path length
"
fan_out_optimization="
If fan-out>4, add buffers or split paths
"
power_optimization="
Minimize switching, size gates properly
"
timing_optimization="
Balance path delays, reduce glitch hazards
"

[OPTIMIZATION_VERIFICATION]
checklist="
✓ Gate count reduced
✓ Critical path minimized
✓ Fan-out within limits
✓ Power reasonable
✓ No timing violations
✓ Functionality preserved
"

[OPTIMIZATION_METRICS]
performance_measures="
1. Gate Count (pre vs. post-optimization)
2. Delay (max path, average path)
3. Fan-out (max, average)
4. Area (gate area, routing)
"



The minimal CPU comprising an instruction memory, a data memory, a register file, and a simple ALU:
Computer Architecture Report
1. Introduction
This lab project explores the design and integration of a 4-bit adder as part of a simplified computer architecture. The system includes:
A Carry-Lookahead Adder (CLA)-based ALU to perform arithmetic (addition/subtraction).
A Register File for temporary operand storage.
Instruction Memory (program ROM) and Data Memory (SRAM).
A Control Unit that decodes instructions and orchestrates data movement.
Objective: Demonstrate how the complete adder design fits into the overall computer architecture and verify correct functionality via a short program.

2. Complete Adder Implementation
2.1 Structure Overview
The system uses a 4-bit CLA Adder within the ALU, enabling single-cycle addition and subtraction.
Internally, the CLA uses half adders and full adders, with logic optimized to reduce carry propagation delay.
When the AddSub control signal is asserted, the ALU either performs addition (AddSub=0) or subtraction (AddSub=1) by inverting one operand and adding a carry of 1.
2.2 Half Adder and Full Adder
Half Adder A half adder takes two single bits (A, B) and produces a sum and carry.

Full Adder A full adder extends the half adder concept by incorporating an incoming carry bit (). It produces a final sum and an outgoing carry ().

2.3 Carry-Lookahead Adder (CLA) Concept
Rather than propagating the carry bit sequentially through each full adder (as with a simple ripple-carry adder), the CLA computes carry signals in parallel using the Generate (G) and Propagate (P) terms:



For a 4-bit CLA block, we derive  in parallel, significantly speeding up multi-bit addition or subtraction.
2.4 Integration into the ALU
The ALU integrates the 4-bit CLA to perform ADD or SUB.
Control Signal (AddSub):
0: Perform Addition
1: Perform Subtraction (by inverting one operand and feeding in a carry-in of 1).
Outputs:
Sum[3:0]: The 4-bit arithmetic result
Cout: Carry-Out (used for overflow or carry detection)
Register File Connection: The ALU reads two register operands, processes them, and writes the result back to a destination register.

3. The Computer Architecture
3.1 Major Components
Instruction Memory
Stores the program instructions (8 bits per instruction).
Program Counter (PC) increments to fetch each instruction in sequence.
Register File
Holds multiple 4-bit registers (e.g., R0, R1, R2, R3).
Supports two reads (operands) and one write (result) each cycle.
Data Memory
4 memory locations, each 4 bits wide.
Addressed via a 2-bit address line, used by LOAD and STORE.
ALU (with CLA)
Performs 4-bit addition or subtraction.
Receives operands from the register file or from data memory (depending on control signals).
Produces a 4-bit result.
Control Unit
Decodes the 8-bit instruction.
Generates control signals for the ALU, register file read/write, and data memory access.
Manages the AddSub, WrMem, and WrReg signals among others.
3.2 Instruction Set Architecture
All instructions are 8 bits wide and follow this format:
  [ OPCODE (2 bits ) ] [ Register/Operand fields (5 bits) ] [ Unused/reserved (1 bit) ] 
We define four primary instructions:
ADD (00)
Format: 00 dest[2:0] X src[1:0]
Action: dest = dest + src
SUB (01)
Format: 01 dest[2:0] X src[1:0]
Action: dest = dest – src
STORE (10)
Format: 10 reg[2:0] X addr[1:0]
Action: Write the content of reg to data memory at addr.
LOAD (11)
Format: 11 reg[2:0] X addr[1:0]
Action: Read data from memory at addr into register reg.
Where:
dest/reg is a 3-bit register specifier (e.g., R0=000, R1=001, R2=010, R3=011, etc.).
src can be another register specifier.
addr[1:0] is a 2-bit memory address (from 0 to 3).
3.3 Sample Program
Below is a short program that demonstrates the instruction set in action:

3.3 Sample Program
Below is a short program that demonstrates the instruction set in action:
    LOAD  R0, 0   ; Instruction = 11 000 X 00                     ; Load from memory address 0 into R0      LOAD  R1, 1   ; Instruction = 11 001 X 01                   ; Load from memory address 1 into R1      ADD   R3, R1  ; Instruction = 00 011 X 01                   ; R3 = R3 + R1 (assume R3 initially 0)                   ; Alternatively, if you want to add R0 and R1:                   ; 00 011 X 00 => R3 = R3 + R0      STORE R3, 3   ; Instruction = 10 011 X 11                   ; Store the content of R3 to memory address 3 
LOAD R0,0: Transfers data from DataMem[0] into register R0.
LOAD R1,1: Transfers data from DataMem[1] into register R1.
ADD R3,R1: Adds R1 to R3 (or R0 to R3 if you adjust the fields) using the ALU's CLA.
STORE R3,3: Writes the new value of R3 to DataMem[3].

4. Implementation Details
4.1 Data Path
Instruction Fetch:
PC outputs the current address to Instruction Memory.
Instruction is latched into the Instruction Register.
Instruction Decode:
The Control Unit parses the 8-bit instruction.
Determines if an ALU operation or memory operation is needed.
Execution:
If ADD/SUB, the ALU reads registers specified in the instruction.
If LOAD/STORE, the address lines connect to Data Memory.
Write-Back:
ALU result or loaded data is written back to the destination register.
4.2 Control Flow
The design is single-cycle, meaning fetch, decode, execute, and write-back happen within one clock cycle per instruction (for this simplified model).
The Control Unit enables or disables signals (e.g., WrMem for STORE, WrReg for register writes, AddSub for ALU operation, etc.).

5. Testing and Verification
5.1 Adder Testing
Component-Level: Verify the half adder and full adder truth tables.
Integration: Confirm correct carry output in multi-bit addition.
5.2 System-Level Testing
Simulation: Use test benches that cycle through instruction sequences, checking register contents and memory updates.
Edge Cases: Confirm behavior with memory boundary addresses (0 and 3) and test overflow cases in the ALU.
5.3 Example Test Bench Requirements
Setup and Hold Times: 1 ns each, with a maximum propagation delay of 10 ns.
Worst-Case Inputs: Test maximum carry generation in the ALU (e.g., 0xF + 0xF).
Memory Access: Ensure correct data retrieval and storage timing.

6. Performance Characteristics
Single-Cycle Operation: The architecture completes one instruction per clock cycle (in this simplified design).


## 1. **Overall Block Diagram**

1. **Instruction Memory (X1)**
   - Holds the machine instructions in a small SRAM-like block.
   - The Program Counter (PC) feeds the address signals (`Addr[2:0]` in the screenshot), incremented each clock cycle to fetch successive instructions.
   - The output (`INSTR[7:0]`) is latched or read directly by control circuitry and the register file.

2. **Data Memory (X6)**
   - Stores data that can be read/written by LOAD and STORE instructions.
   - Address lines come from either the register file output or instruction bits, depending on how your control is set up.
   - A `WMem` (write enable) signal allows data to be stored when the CPU executes a STORE instruction.

3. **Register File (X3)**
   - A small set of internal registers (R0, R1, R2, R3, for example).
   - The CPU can read from two source registers and write to one destination register each cycle (depending on the instruction).
   - Each register is typically 8 bits wide (or whatever width matches your ALU/data memory).

4. **ALU / Arithmetic-Logic Stage (the blocks labeled `Add0sub1`, `Sum[3:0]`, etc.)**
   - Performs ADD or SUB operations based on an ALU control bit (`Add0sub1`).
   - For ADD, it sums two register values. For SUB, it subtracts.
   - The result is fed back either to the register file or to data memory (STORE), depending on the instruction.

5. **Control Signals**
   - Decoded from the instruction bits. Typically, the instruction format might be:
     ```
     [7:5] = Op-code
     [4:3] = Destination Register
     [2:1] = Source Register
     [0]   = Possibly an immediate flag or an ALU control bit
     ```
     or a similar scheme.
   - The control logic sets:
     - **ALU operation** (Add/Sub)
     - **Write Enable** for register file
     - **Memory Write Enable (WMem)**
     - **Source/destination register selects**
     - **Increment PC** or jump (if you have a jump instruction)

---

## 2. **Instruction Set Overview**

Your schematic mentions four op‐codes (though more can be added if desired):

1. **ADD** (`00` in binary, or op‐code = 0 decimal)
   - Performs `Rdest = Rdest + Rsource` (A + B).
   - `Add0sub1 = 0` so the ALU does addition.

2. **SUB** (`01` in binary, or op‐code = 1 decimal)
   - Performs `Rdest = Rdest - Rsource`.
   - `Add0sub1 = 1` for subtraction in the ALU.

3. **LOAD** (`10` in binary, or op‐code = 2 decimal)
   - Loads data from Data Memory into the destination register.
   - The address for Data Memory may come from:
     - The instruction bits themselves (immediate address), or
     - Another register (indirect addressing)—depending on how the control is wired.

4. **STORE** (`11` in binary, or op‐code = 3 decimal)
   - Stores the contents of the source register back to Data Memory.
   - Memory address also depends on instruction bits or register output.

> **Note:** The exact bit‐field layout (e.g., which bits pick "source register" vs. "destination register") can vary by design. The schematic shows signals like `AI[3:0]`, `BI[3:0]`, `WrAdd[1:0]`, etc., which the control logic must generate correctly.

---

## 3. **Program Flow Example**

At the bottom right of your schematic, there is a tiny "program" in assembly‐like form (lines such as `LOAD R0 0x00`, `LOAD R1 0x01`, etc.). This snippet shows the typical flow:

1. **LOAD R0, 0x00**
   - Op-code = `10` (LOAD).
   - The destination register is R0.
   - The address for Data Memory is `0x00`.
   - Result: R0 ← DataMem[0x00].

2. **LOAD R1, 0x0C**
   - Another LOAD, now to R1.
   - DataMem[0x0C] is read into R1.
   - Could be some constant or variable stored at memory address 0x0C.

3. **ADD R3, R2**
   - Op-code = `00` (ADD).
   - The "destination" might be R3, and "source" is R2.
   - R3 ← R3 + R2.
   - (In some designs, the ALU input for "A" is R3, "B" is R2.)

4. **STORE R3, 0x0F**
   - Op-code = `11` (STORE).
   - DataMem[0x0F] ← R3.
   - Writes the contents of R3 into memory location 0x0F.

And so on. Each instruction is one byte (or more, if your design uses immediate addresses). The Program Counter increments each clock, fetching the next instruction from Instruction Memory (X1).

---

## 4. **Putting It All Together**

- **Fetch**: The CPU reads the instruction from Instruction Memory at the address pointed to by the PC.
- **Decode**: The instruction bits are split into op-code and register specifiers. Control signals are set accordingly (Add vs. Sub, read vs. write memory, etc.).
- **Execute**:
  - If ADD/SUB, the ALU reads two registers (source, destination), performs the operation, and writes the result back.
  - If LOAD, the CPU reads Data Memory into a register.
  - If STORE, the CPU writes the content of a register out to Data Memory.
- **Write‐Back**: The destination register (or memory) is updated if required.
- **Increment PC**: The PC increments to fetch the next instruction.

Since this is a simple, in‐class demonstration, the architecture is minimal—just enough to show how instructions, data memory, and a small ALU interact.

---

## 5. **Relation to the Half Adder Documentation**

Your provided "Half Adder Design Documentation" is a **template** (or "lab report structure") for describing any digital design thoroughly:

- Notation, truth tables, K‐map analysis, gate‐level design, simulation steps, etc.
- You can apply the **same** style to the "computer" design: define input signals (e.g., clock, instruction bits, register addresses), outline the truth table for each instruction or micro‐operation, show partial schematics, and so forth.

While the half adder is obviously much simpler, the same pattern of:
1. Defining inputs/outputs,
2. Writing truth tables or functional specs,
3. Implementing in gates (AND, OR, MUX, etc.),
4. Verifying with simulation,

applies on a larger scale to your CPU.

---

## 6. **Key Takeaways and Tips**

1. **Modular Design**
   - Break the CPU into modules (Instruction Memory, Data Memory, Register File, ALU, Control).
   - Test each module in isolation before combining everything.

2. **Clear Instruction Format**
   - Document precisely which bits do what (e.g., bits [7:5] = opcode, bits [4:3] = dest, bits [2:1] = source).
   - This avoids confusion when writing or debugging the program.

3. **Memory Access**
   - For LOAD/STORE, ensure the correct address lines go to the Data Memory.
   - Check that `WMem` (write enable) only activates on STORE.

4. **Simulation**
   - In LTspice, define the clock signals (for the PC, registers) and run a transient analysis.
   - Step through each instruction to confirm that registers and memory change as expected.

5. **Incremental Testing**
   - Start with a short program: e.g., LOAD R0, 0x00 → LOAD R1, 0x01 → ADD R2, R0 → STORE R2, 0x02.
   - Verify each step in the waveforms. If it matches the expected CPU state at every clock, you're good.

6. **Extend and Optimize**
   - Once it works in principle, you can add instructions (like jump, compare, or immediate constants).
   - You can also refine the ALU to handle more operations (bitwise AND, OR, etc.).
   - Expand memory address width or register count if the design becomes too limiting.

---

### Conclusion ("Solution Endpoint")

The in‐class CPU is a simple demonstration of how digital logic blocks—memories, register files, and an ALU—tie together under a small instruction set. By systematically **fetching, decoding, executing, and writing back**, it implements basic operations (ADD, SUB, LOAD, STORE).

You can adapt the **formal structure** used in the Half Adder documentation for a detailed, step‐by‐step lab report of this CPU:

- **[NOTATION_KEY], [Possible Inputs], [Truth Table], [Gate Operations], [Simulation_and_Results],** etc.

That formal method helps ensure **every** piece of the design is verified, checked for consistency, and documented thoroughly—making debugging and future enhancements much easier.

---

*After finalizing, consider filling out your own "verification checklists" for each CPU module (e.g., verifying the ALU's add/sub function, the register file read/write logic, the memory addresses, etc.) to confirm correctness.*